<font color="green" size=4>更多读书笔记关注公众号:**零K同学**<font>

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-02/公众号二维码.75dvf969t4w0.png)

- [`C`和`C++`的区别](#c和c的区别)
- [面向对象的三大特性是](#面向对象的三大特性是)
- [多态的实现](#多态的实现)
- [C++虚函数相关，虚函数的实现原理](#c虚函数相关虚函数的实现原理)
- [虚函数表是如何实现动态绑定的](#虚函数表是如何实现动态绑定的)
- [编译器处理虚函数表应该如何处理](#编译器处理虚函数表应该如何处理)
- [基类的析构函数为什么一般写成虚函数](#基类的析构函数为什么一般写成虚函数)
- [构造函数为什么一般不定义为虚函数](#构造函数为什么一般不定义为虚函数)
- [构造函数或者析构函数中调用虚函数会怎样](#构造函数或者析构函数中调用虚函数会怎样)
- [静态绑定和动态绑定的介绍](#静态绑定和动态绑定的介绍)
- [纯虚函数](#纯虚函数)
  - [虚函数和纯虚函数区别](#虚函数和纯虚函数区别)
- [哪些函数不能是虚函数](#哪些函数不能是虚函数)
- [静态函数能定义为虚函数吗](#静态函数能定义为虚函数吗)
- [构造函数、析构函数的执行顺序](#构造函数析构函数的执行顺序)
- [类什么时候会析构](#类什么时候会析构)
- [有没有了解过(复制)拷贝构造函数](#有没有了解过复制拷贝构造函数)
- [说一下深拷贝和浅拷贝](#说一下深拷贝和浅拷贝)
- [C++内存管理(内存分区)](#c内存管理内存分区)
- [内存泄漏的定义，什么时候会造成内存泄漏](#内存泄漏的定义什么时候会造成内存泄漏)
- [内存泄漏避免方法](#内存泄漏避免方法)
- [`new/delete` 与 `malloc/free` 的异同](#newdelete-与-mallocfree-的异同)
- [new和delete是如何实现的](#new和delete是如何实现的)
  - [`delete`和`delete[]`的区别](#delete和delete的区别)
- [malloc申请的存储空间能用delete释放吗](#malloc申请的存储空间能用delete释放吗)
- [new和malloc失败情况](#new和malloc失败情况)
- [结构体的内存对齐](#结构体的内存对齐)
- [C++中struct和class的区别](#c中struct和class的区别)
  - [C++和C的struct区别](#c和c的struct区别)
- [C语言中 struct（结构体） 和 union（联合体） 的区别是什么](#c语言中-struct结构体-和-union联合体-的区别是什么)
- [main函数执行之前和执行之后有什么区别](#main函数执行之前和执行之后有什么区别)
- [**可执行文件编译过程**](#可执行文件编译过程)
  - [程序的执行过程](#程序的执行过程)
    - [预编译](#预编译)
    - [编译](#编译)
    - [汇编](#汇编)
    - [链接](#链接)
  - [编译器的工作原理](#编译器的工作原理)
    - [词法分析](#词法分析)
    - [语法分析](#语法分析)
    - [语义分析](#语义分析)
    - [代码生成](#代码生成)
    - [目标代码优化](#目标代码优化)
- [类对象所占用的内存](#类对象所占用的内存)
- [`A a`和`A *aa = new A()`区别](#a-a和a-aa--new-a区别)

-----

## `C`和`C++`的区别

包括但不限于：

* `C`是面向过程的语言，`C++`是面向对象的语言，所以`C++`也就具有面向对象的三大特性。分别是“**封装，继承和多态**”  

* `C` 和`C++`内存管理的方法不同。`C`使用`malloc/free`，`C++`除此之外还用`new/delete`。==> [malloc/free和new/delete的区别](#newdelete-与-mallocfree-的异同)

* `C` 中的结构体`struct`和`C++`的类的也是有区别的。==> [C++中struct和class的区别](#c和c的struct区别)

* `C++` 支持函数重载，`C`不支持函数重载。而且`C++`中允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而`C`语言中，必须要在函数开头部分。而且`C++`允许重复定义变量，`C`语言也是做不到这一点的。


* `C++` 中有引用和指针，而 `C` 有指针，但是没有引用。==> [引用和指针是有区别的](#指针和引用的区别)

* 内外链接区别，`C++`全部变量的默认链接属性是外链接，而`C`是内连接。[内连接和外链接区别](#内连接与外连接)

* `C` 语言和`C++`的一些关键字也不同。如`const`，`C`语言中的`const`：被修饰后不能做左值，一开始初始化后只有就不能再修改了。定义的时候必须初始化，可以用作数组的下标。`const`在`C++`中的编译规则是替换（和宏`#define`很像）；==> [可能会被问define和const的联系与区别](#define和const的联系与区别)

* 还有其他的不同，比如输入输入输出，`C`语言没有`string`字符串类型等等吧。

## 面向对象的三大特性是

* **封装**：隐藏了类的实现细节和成员数据，实现了代码模块化，并且类可以把自己的数据和方法只让可信的类或者对象操作，例如：将公共的数据或方法使用`public`修饰，而不希望被访问的数据或方法采用`private`修饰。 `[ˈpraɪvət]`

* **继承**：让子类可以继承父类的成员和方法，实现了代码重用；
  * 常见的继承有三种方式：

  1. 实现继承：指使用基类的属性和方法，子类不需要额外实现
  2. 接口继承：指仅仅使用属性和方法的名称、但是子类必须提供实现的能力
  3. 可视继承：（C++里好像不怎么用，没深入去研究）


* **多态**：是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用。如父类的指针指向子类的对象。**多态的实现机制是虚函数**

## 多态的实现

C++多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。

**C++是依靠虚函数来实现动态多态的**

## C++虚函数相关，虚函数的实现原理

虚函数：在基类的函数前加上`virtual`关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.

**`C++`的虚函数是实现多态的机制**。它是通过虚函数表和虚表指针实现的，虚表是一个指针数组，它存放着指向虚函数的指针，类的实例在调用虚函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。

## 虚函数表是如何实现动态绑定的

>  虚函数的动态绑定是利用**虚表**和**虚表指针**实现的

假如有一个类 B 继承另一个类 A ，如果基类 A 中有包含了虚函数，那么继承类 B 就可以调用基类 A 的虚函数，也就是说一个类继承了包含虚函数的基类，那么这个类就应有自己的虚表。

我们来看以下的代码。类 A 包含虚函数`vfunc1`，`vfunc2`，由于类 A 包含虚函数，故类 A 拥有一个虚表。

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};
```

![虚函数表01](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表01.png)

**虚表是一个指针数组，它存放着指向虚函数的指针**，普通函数也就非虚函数，它的调用不需要经过虚表，所以虚表中并没有存放指向非虚函数的指针。

为了指定对象的虚表，对象中包含一个指向虚表的指针，指向自己的虚表，为了让每个包含虚表的类的对象都用一个虚表指针，编译器在类中添加一个指针`*__vptr`，每个类创建的对象的时候这个指针默认指向类的虚表。

![虚函数表02](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表02.png)

一个继承类的基类如果包含虚函数，那这个继承类也有拥有自己的虚表，所以这个继承类的对象也包含一个虚表指针，用来指向它的虚表。

**那么C++ 是如何利用虚表和虚表指针来实现动态绑定的呢**？

```cpp
class A {
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1, m_data2;
};

class B : public A {
public:
    virtual void vfunc1();
    void func1();
private:
    int m_data3;
};

class C: public B {
public:
    virtual void vfunc2();
    void func2();
private:
    int m_data1, m_data4;
};
```

类 A 是基类，类 B 继承类 A，类 C 又继承类 B。类 A，类 B，类 C，其对象模型如下图所示。

![虚函数表03](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚函数表03.png)

由于这三个类都有虚函数，所以编译器为每个类都创建了一个虚表，即类 A 的虚表（`A vtbl`），类 B 的虚表（`B vtbl`），类 C 的虚表（`C vtbl`）。类 A，类 B，类 C 的对象都拥有一个虚表指针，`*__vptr`，用来指向自己所属类的虚表。

类 A 包括两个虚函数，故 `A vtbl` 包含两个指针，分别指向`A::vfunc1()`和`A::vfunc2()`。
类 B 继承于类 A，故类 B 可以调用类 A 的函数，但由于类 B 重写了`B::vfunc1()`函数，故 `B vtbl` 的两个指针分别指向`B::vfunc1()`和`A::vfunc2()`。
类 C 继承于类 B，故类 C 可以调用类 B 的函数，但由于类 C 重写了`C::vfunc2()`函数，故 `C vtbl` 的两个指针分别指向`B::vfunc1()`（指向继承的最近的一个类的函数）和`C::vfunc2()`。

综上所诉，对象的虚表指针用来指向自己所属类的虚表，虚表中的指针会指向它继承的最近的一个类的虚函数。

非虚函数的调用不用经过虚表，所以不需要虚表中的指针指向这些函数


参考：[C++虚函数表剖析](https://blog.csdn.net/lihao21/article/details/50688337)

## 编译器处理虚函数表应该如何处理

编译器处理虚函数的方法是：

如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。

为每个类的实例添加一个虚表指针（`vptr`），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。

参考这上面的[虚函数表是如何实现动态绑定的](#虚函数表是如何实现动态绑定的)

## 基类的析构函数为什么一般写成虚函数

首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。

如果析构函数不被声明成虚函数，则编译器实施**静态绑定**，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。

> 直接的讲，C++中基类采用`virtual`虚析构函数是为了防止内存泄漏。

## 构造函数为什么一般不定义为虚函数

1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，**由于对象还未创建成功，编译器无法知道对象的实际类型**，是类本身还是类的派生类等等

2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数，所以构造函数不能定义为虚函数。

 3） 从使用角度，虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。


## 构造函数或者析构函数中调用虚函数会怎样

根据虚函数底层实现原理(但是最好不要在构造和析构函数中调用)，可以调用，但是没有动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数。 

《effictive c++》第九条，绝不在构造和析构过程中调用 virtual,因为构造函数中的 基类 的虚函数不会下降到 子类 上。而是直接调用基类的虚函数。

a) 如果有继承，构造函数会先调用父类构造函数，而如果构造函数中有虚函数，此时子类还没有构造，所以此时的对象还是父类的，不会触发多态。所以在基类构造期间，virtual 函数没有起到 virtual 函数的作用。

b) 析构函数也是一样，子类先进行析构，这时，如果有 virtual 函数的话，子类的内容已经被析构了，C++ 会视其父类，执行父类的 virtual 函数。

c) 总之，在构造和析构函数中，不要用虚函数。如果必须用，那么分离出一个 Init 函数和一个 close 函数，实现相关功能即可。
 
## 静态绑定和动态绑定的介绍

[C++中的静态绑定和动态绑定](https://www.cnblogs.com/lizhenghn/p/3657717.html)

静态绑定：也就是将该对象相关的 『属性』 或 『函数』 绑定为它的静态类型，也就是它声明的类型，在**编译的时候**就确定了。在调用的时候编译器会寻找它声明的类型进行访问。

静态多态有两种实现方式：

  1.函数重载：包括普通函数的重载和成员函数的重载

  2.函数模板的使用

动态绑定：就是将该对象相关的属性或函数绑定为它的 动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。

## 纯虚函数

纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承

包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象

使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。

### 虚函数和纯虚函数区别

- 虚函数是为了实现动态绑定产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上`virtual`修饰符修饰，因为`virtual`会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。

- 纯虚函数只是相当于一个接口名，所以含有纯虚函数的类不能够实例化。


纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“`=0`”。

既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，**因此它在虚函数表中的值就为 0**，而具有函数体的虚函数则是函数的具体地址。

一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。

举个例子：

```C++
#include <iostream>
using namespace std;

class Base
{
public:
	virtual void fun1()
	{
		cout << "普通虚函数" << endl;
	}
	virtual void fun2() = 0;
	virtual ~Base() {}
};

class Son : public Base
{
public:
	virtual void fun2() 
	{
		cout << "子类实现的纯虚函数" << endl;
	}
};

int main()
{
	Base* b = new Son;
	b->fun1(); //普通虚函数
	b->fun2(); //子类实现的纯虚函数
	return 0;
}
```

## 哪些函数不能是虚函数

1)  构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；

2)  内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间才进行类型确定，所以内联函数不能是虚函数；

3)  静态函数，静态函数不属于对象属于类，静态成员函数没有`this`指针，因此静态函数设置为虚函数没有任何意义。

4)  友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。

5)  普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。

## 静态函数能定义为虚函数吗

1、`static`成员不属于任何类对象或类实例，所以即使给此函数加上`virutal`也是没有任何意义的。

2、静态与非静态成员函数之间有一个主要的区别，那就是静态成员函数没有`this`指针。

虚函数依靠`vptr`和`vtable`来处理。`vptr`是一个指针，在类的构造函数中创建生成，并且只能用`this`指针来访问它，因为它是类的一个成员，并且`vptr`指向保存虚函数地址的`vtable`.对于静态成员函数，它没有`this`指针，所以无法访问`vptr`。

所以`static`函数不能为`virtual`，虚函数的调用关系：`this -> vptr -> vtable ->virtual function`


## 构造函数、析构函数的执行顺序

- 1) 构造函数顺序

① 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。

② 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。

③ 派生类构造函数。

- 2) 析构函数顺序

① 调用派生类的析构函数；

② 调用成员类对象的析构函数；

③ 调用基类的析构函数。

## 类什么时候会析构

对象生命周期结束，被销毁时；

`delete`指向对象的指针时，或`delete`指向对象的基类类型指针，而其基类虚构函数是虚函数时；

比如：对象`A`是对象`B`的成员，`B`的析构函数被调用时，对象`A`的析构函数也被调用。


## 有没有了解过(复制)拷贝构造函数

1.1 拷贝构造函数是一种特殊的构造函数，函数名称必须和类的名称一致，它只有一个参数，参数类型是本类的引用。

1.2 它的作用是用来复制对象，使用这个对象的实例来初始化这个对象的另一个实例

1.3 复制构造函数被调用的三种情况：
- 当用一个对象去初始化同类的另一个对象时，复制构造函数会被调用
```cpp
Complex c2(c1);
Complex c2 = c1;
```
- 函数的返回值是类A的对象时，则类A的复制构造函数会被调用
- 当函数的参数为类的对象时，复制构造函数会被调用
```cpp
#include<iostream>
using namespace std;
class A{
public:
    A(){};
    A(A & a){
        cout<<"Copy constructor called"<<endl;
    }
};
//函数的参数为类A的对象a
void Func(A a){ }
int main(){
    A a;
    Func(a);
    return 0;
}
```
程序的输出结果为：      
`Copy constructor called`           
这是因为 Func 函数的形参 a 在初始化时调用了复制构造函数。

1.4 此外，拷贝构造函数默认为**浅拷贝**，浅拷贝是指当前类进行等号赋值时，它能够完成静态成员的值复制。当数据成员中没有指针时，浅拷贝是可行的。但是当数据成员中有指针时，如果采用简单的浅拷贝，那么这两个类中的指针将指向同一个地址，对象即将结束时，两个类会分别调用析构函数，导致指针悬挂现象。所以这时必须采用深拷贝，在堆内存中另外申请空间来储存数据，防止指针悬挂现象。==>[说一下深拷贝和浅拷贝](/寻offer总结/Cpp基础/Cpp知识点02?id=说一下深拷贝和浅拷贝)

1.5 还有就是，拷贝构造函数**必须是引用传递，不能是值传递**，这是为了防止递归引用。

## 说一下深拷贝和浅拷贝

- **浅拷贝**将源对象的值拷贝到目标对象中去，也就是说源对象和目标对象使用的还是同一个实体，只是他们的变量名不同，但是它们的地址是相同的。

- **深拷贝**在拷贝时先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标拷贝对象中去，这样两个指针就指向了不同的内存位置，并且里面的内容还是一样的。在拷贝构造函数中深拷贝可以解决指针悬挂问题。

-----

## C++内存管理(内存分区)

在操作系统中，不同应用程序之间的内存时相互独立的，一般不能互相进行访问。

一个引用程序的内存一般分成五个区：

- 栈区：栈区存储的是一些临时变量，包括局部变量，返回值，参数，返回地址等等。栈空间是有存储大小的，如果超过这个大小将会出现栈溢出。
- 堆区：堆区是一个比较大的内存空间，主要用来动态分配内存，这一部分通常由程序员进行分配和释放。如果在程序结束的时候还未释放，就会被操作系统回收。
- 全局区：存放**未初始化**的静态变量和全局变量
- 数据区：存放**初始化**的静态变量和全局变量
- 代码区：代码区存储的就是可执行的代码，这个区域的属性是只读的。

![C++内存管理](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/C++内存管理.png)

编写一段代码来了解内存四区的底层结构

```cpp
#include<stdio.h>
int main()
{
 int a = 0;
 int b = 0;
 char c='0';
 printf("变量int a的地址是：%d\n变量int b的地址是：%d\n变量char c的地址是：%d\n", &a, &b, &c);
}
```

运行结果

```
变量int a的地址是：-332826852
变量int b的地址是：-332826856
变量char c的地址是：-332826857
```

可以发现`a b c` 的地址是连续的，由于`int`是4个字节，所以`a`和`b`之间间隔为4，`char`是一个字节，所以`b`与`c`间隔为1。此外，它们的地址是从`a`到`c`减少的，这是因为栈的存储结构是**先进后出**。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/C++内存管理01.png)

然后我们加上静态变量`d`和全局变量`e`。

```cpp
#include<stdio.h>
int e = 0;
int main()
{
    int a = 0;
    int b = 0;
    char c='0';
    static int d = 0;
    printf("变量int a的地址是：%d\n变量int b的地址是：%d\n变量char c的地址是：%d\n", &a, &b, &c);
    printf("静态变量static int d的地址是：%d\n" ,&d);
    printf("全局变量int e的地址是：%d\n", &e);
    return 0;
}
```

运行结果：

```
变量int a的地址是：-481331432
变量int b的地址是：-481331436
变量char c的地址是：-481331437
静态变量static int d的地址是：208703516
全局变量int e的地址是：208703512
```
变量 `d` 为静态变量，运行代码后从结果上得知，静态变量 `d`的地址与一般变量 `a`、`b`、`c` 的地址并不存在连续，他们两个的内存地址是分开的。那接下来在此建一个全局变量，通过上述内容得知，全局变量与静态变量都应该存储在静态区.

而且可知**栈区、数据区都是使用栈结构对数据进行存储**。

堆并没有和栈一样的结构，也没有栈一样的先进后出，需要人为的对的内存进行分配使用。

```cpp
#include<stdio.h>
#include<string.h>
#include <malloc.h>
int main()
{
 char *p1 = (char *)malloc(1024*1000000);
 strcpy(p1, "这里是堆区");
 printf("%s\n", p1);
}
```

上面的代码使用了`malloc`开辟了一块大小为`1024*1000000`的空间，这个大小如果在栈区就会出现栈溢出的现象，而堆没有，因为堆本身就是大容量。

然后注意`p1`存储的是开辟的内存空间的地址。

## 内存泄漏的定义，什么时候会造成内存泄漏

内存泄露是指在动态分配内存的过程中，忘记释放掉分配的内存或者因为某些原因导致内存无法释放。如果严重的话会导致系统崩溃发生。

- 比如在一个函数中使用`malloc`函数开辟了`100`个单位的内存空间，并没有释放，如果这个函数频繁地被调用，久而久之就会出现严重的后果，所以在使用完之后应该加上`free`进行释放。

- 如果使用`fopen`打开一个文件，使用完之后没有使用`fclose`进行关闭也会导致内存泄漏。

- 还有没有被初始化的指针也会造成内存泄漏，因为指针未初始化的话它的执行是不可控的。包括错误的释放。比如

```cpp
int *p;  //指针未初始化

int pp = p;
free(pp); //错误释放，这里导致指针p出现指针悬挂现象
```

- **没有将基类的析构函数定义为虚函数**，当基类指针指向子类对象时，如果基类的析构函数不是`virtual`，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露


## 内存泄漏避免方法

1. **`malloc/free`要配套使用**

2. **使用智能指针**

3. **将基类的析构函数设为虚函数**；

4. **`fopen/fclose`要配套使用**

## `new/delete` 与 `malloc/free` 的异同

它们都用于动态申请内存和释放。

- `new/delete` 是`C++`的运算符,`malloc/free`是`C/C++`标准库函数，
- 在`C++`中分别使用`new` 和 `delete`来分配和释放内存。`new` 和 `delete`**是运算符，不是函数**。`new/delete`相对于`malloc/free`除了分配和释放内存之外还做了其他很多事情。
  - `new` 相对于 `malloc` 会额外的做一些初始化工作，
  - `delete` 相对于 `free` 多做一些清理工作。
  - 比如说使用`new`生成一个对象时，系统会调用这个类的构造函数，使用`delete`删除一个对象时，系统会调用这个类的析构函数。


```cpp
class A
{
 public:
     A()
     {
        cont<<"A()构造函数被调用"<<endl;
     }
     ~A()
     {
        cont<<"~A()构造函数被调用"<<endl;
     }
}

//在 main 主函数中，加入如下代码

A* pa = new A();  //类 A 的构造函数被调用
delete pa;        //类 A 的析构函数被调用
```

- `new`是封装了`malloc`，直接`free`不会报错，但是这只是释放内存，而不会析构对象。

## new和delete是如何实现的

- `new`的实现过程是：
  - 底层是通过 **operator new** 分配内存来保存这个类（类型）的对象，接下来运行构造函数，初始化构造对象，然后返回指向构造出来的对象的指针

- `delete`的实现过程：
  - 首先调用析构函数，然后通过 **operator delete** 来释放内存


### `delete`和`delete[]`的区别

* `delete`只会调用一次析构函数，而`delete[]`会调用每个成员的析构函数

* 用`new`分配的内存用`delete`释放，用`new[]`分配的内存用`delete[]`释放

假如说使用`new int[10]`来开辟一个内存空间，针对这种简单类型，使用`new`分配后不管是数组还是非数组形式释放都是可以的。他们的效果是一样的，**因为分配简单类型内存的时候，内存大小已经确定，系统可以记忆并且进行管理，在析构时，系统不会调用析构函数**。它直接通过指针可以获取实际分配的内存空间，哪怕是一个数组内存空间。

> 实际上，C++ 在分配数组空间的时候 多分配了 4 个字节的大小，专门保存数组的大小。在 `delete[]` 的时候就可以取出这个数组的大小的数字，就知道需要调用析构函数多少次了。

```cpp
int *a = new int[10];
delete a;        //方式1
delete[] a;     //方式2

int *a = new int[10];
delete a;
delete[] a;
```

但是如果针对类`class`，两种方式就出现差异了。

```cpp
class A
{
private:
    char *m_cBuffer;
    int m_nLen;

public:
    A(){ m_cBuffer = new char[m_nLen]; }
    ~A() { delete [] m_cBuffer; }
};

A *a = new A[10];
delete a;         
//仅释放了a指针指向的(首地址)全部内存空间 
//但是只调用了a[0]对象的析构函数 
//剩下的从a[1]到a[9]这9个用户自行分配的 m_cBuffer 对应内存空间将不能释放 从而造成内存泄漏
delete[] a;      
//调用使用类对象的析构函数释放用户自己分配内存空间并且释放了a指针指向的全部内存空间
```

所以在用这些类生成**对象数组**的时候，建议用 `delete[]` 来释放。

## malloc申请的存储空间能用delete释放吗

不能，`malloc /free` 主要为了兼容`C`，`new`和`delete` 完全可以取代`malloc /free` 的。

`malloc /free` 的操作对象都是必须明确大小的，而且不能用在动态类上。

`new` 和`delete` 会自动进行类型检查和大小，`malloc/free`不能执行构造函数与析构函数，所以动态对象它是不行的。

当然从理论上说使用`malloc`申请的内存是可以通过`delete`释放的。不过一般不这样写的。而且也不能保证每个`C++`的运行时都能正常。

## new和malloc失败情况

Linux 内核有一个参数`/proc/sys/vm/overcommit_memory`，是内存分配策略之一，会影响malloc分配内存结果，其值可以是0、1、2。                               
- 0， 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。 
- 1， 表示申请虚拟内存一定成功，而不管当前的物理内存状态如何。
- 2， 表示申请虚存时，检查允许分配超过所有物理内存和交换空间总和的内存。

## 结构体的内存对齐

**内存对齐是一种用空间换时间以提高效率的方式**。

**为什么会有内存对齐**？

主要是两个原因

- 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。

- 硬件原因：经过内存对齐后，`CPU`访问内存的速度大大提升。

可以看一下这段C++代码输出的各个数据类型大小是多少？
```cpp
struct node{
   int num;
   char cha;
}st;
int main() {
    int a[100];
    char b[100];
    cout << sizeof(int) << endl;
    cout << sizeof(char) << endl;
    cout << sizeof(a) << endl;
    cout << sizeof(b) << endl;
    cout << sizeof(st) << endl;
}
```
看一下和自己想的结果一样么， 我们来逐一分析一下。

其输出的结果依次为：
```
4
1
400
100
8
```
此时会发现，和单纯计算字节数的话是有一些误差的。

这就是因为内存对齐的原因。

**来看一下内存对齐和非内存对齐产生的效果区别**。

`CPU`读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是`2，4，8，16`个字节，具体取多少个字节取决于硬件。

假设`CPU`把内存划分为`4`字节大小的块，要读取一个`4`字节大小的`int`型数据，来看一下这两种情况下`CPU`的工作量：

第一种就是内存对齐的情况，如图

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存对齐01.png)

一字节的`char`占用了四个字节，空了三个字节的内存地址，`int`数据从地址`4`开始。

此时，直接将地址`4，5，6，7`处的四个字节数据读取到即可。

第二种是没有内存对齐的情况如图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存对齐02.png)

`char`型的数据和`int`型的数据挨在一起，这个`int`数据从地址`1`开始，那么`CPU`想要读这个数据的话,来看看需要几步操作：

因为`CPU`是四个字节四个字节来寻址，

首先`CPU`读取`0，1，2，3`处的四个字节数据

然后`CPU`读取`4，5，6，7`处的四个字节数据

最后还要合并地址`1，2，3，4`处四个字节的数据才是本次操作需要的`int`数据

此时**一共需要两次寻址，一次合并的操作**。

大家可能会发现内存对齐岂不是浪费的内存资源么？

是这样的，但事实上，相对来说计算机内存资源一般都是充足的，我们更希望的是提高运行速度。

编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响。



## C++中struct和class的区别

两者都拥有成员函数、公有和私有部分,任何可以使用`class`完成的工作，同样可以使用`struct`完成不同点。

两者中如果不对成员不指定公私有，`struct`默认是公有的，`class`则默认是私有的

`class`默认是`private`继承，而`struct`模式是`public`继承

### C++和C的struct区别

`C`语言中：`struct`是用户自定义数据类型（UDT）；`C++`中`struct`是抽象数据类型（ADT），支持成员函数的定义，（`C++`中的`struct`能继承，能实现多态）

`C++`对`C`语言的`struct`进行了扩展，使`struct`在`C++`中可以和`class`一样做为类使用，不同的是`struct`的成员默认访问修饰符是`public`，而`class`默认的是`private`;



## C语言中 struct（结构体） 和 union（联合体） 的区别是什么

- 结构体和联合体虽然都是由多个不同数据类型组成的，但是不同之处在于联合体所有成员**共用一块内存空间**

- 结构体在计算总总长度的时候，它的空间大小等于所有成员总长度之和（当然需要考虑字节对齐）；但是在联合体中，所有成员不能同时占用内存空间，他们不能同时存在，所以一个联合体变量的长度等于所有成员中最长的成员长度。

- 对于联合体的不同成员赋值，将会对他其他的成员重写，原来成员就不存在了，而对结构体的不同成员赋值是互不影响的。



## main函数执行之前和执行之后有什么区别

首先我们来看一段代码

```cpp
#include <iostream>
using namespace std;
class A {
public:
    A() {
        cout << "this is A Contructor" << endl;
    }
    ~A() {
        cout << "this is A distructor" << endl;
    }
};

A a;

int main() {
    cout << "this is main" << endl;
    return 0;
}
```

程序输出：

```
this is A Contructor
this is main
this is A distructor
```
会发现最终打印的不仅仅是`this is main`这句话

以前我总以为所有的代码都是在`main`函数执行之后才会执行的,但其实不是这样的，`main`函数只不过是提供了一个函数的入口而已，在`main`函数中的代码在执行之前，编译器会生成`_main`函数，这时候会进行所有全局对象的构造以及初始化工作。简单的说就是静态变量、全局变量和全局对象的分配是在`main`函数之前完成的，所以`C++`中并非所有的动作都是由于`main`函数引起的。

同样在`main()`函数执行后,程序退出，这时候对全局变量和全局对象进行销毁操作，所以在`main()`函数之后还会执行相应的代码

还可以使用`ateit()`函数，使`main()`函数之后可以执行其他函数。

```cpp
void fun1() {
    cout << "this is fun1" << endl;
}
void fun2() {
    cout << "this is fun2" << endl;
}
int main() {
    atexit(fun1);
    atexit(fun2);
    cout << "this is main" << endl;
    return 0;
}
```

执行结果：
```
this is main
this is fun2
this is fun1
```

PS:

```c
int atexit(void (*func)(void))
//func -- 在程序终止时被调用的函数。
```


## **可执行文件编译过程**

**预处理，编译，汇编，链接**

> hello.c 程序的编译过程


以下是一个 hello.c 程序：

```c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}


```

在 Unix 系统上，由编译器把源文件转换为目标文件。

```bash
gcc -o hello hello.c
```

这个过程大致如下：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/编译过程01.dzgn990flrs.png)

- 预处理阶段：处理以 # 开头的预处理命令；
- 编译阶段：翻译成汇编文件；
- 汇编阶段：将汇编文件翻译成可重定位目标文件；
- 链接阶段：将目标文件彼此链接起来


**源代码－－>预处理－－>编译－－>优化－－>汇编－－>链接-->可执行文件**

### 程序的执行过程

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/gcc编译过程.2h7in83bph60.jpg)

#### 预编译


```
gcc -E hello.c -o hello.i
```

- 展开所有的宏定义
- 删除所有的注释
- 添加行号和文件标识

#### 编译

```
gcc -S hello.i -o hello.s
```

一系列的词法分析和语法分析，得到汇编输出文件 hello.s

#### 汇编

```
as hello.s -o hello.o
```

汇编器将汇编代码转变成机器可以识别的指令。

#### 链接

将所有相关的文件链接起来得到 a.out 可执行文件

### 编译器的工作原理

#### 词法分析

将源代码输入 扫描器，扫描器运用一种 优先状态机 算法给代码中的每个 符号 进行标记产生 **记号**

#### 语法分析

对扫描器产生的记号进行语法分析，产生**语法树**，将整个 语句 看成一个 表达式。
比如： a + b 

```
   +
  /  \
 a    b
```

#### 语义分析

接下来由 语义分析器 对表达式的语法层面进行分析。

#### 代码生成

通过 源码级优化器 进行优化。

比较常见的有：三地址编码

```
x = y op z
```

变量 y 和 z 进行 op 操作之后得到 x

```
array[index] = [index+4] * (2 + 6)
```

为了使所有的操作都满足三地址编码，中间会利用临时变量。

``
t1 = 2 + 6
t2 = index + 4
t3 = t2 * t1
array[index] = t3
```

因为 2+6 在编译器可以确定，所以可以优化，此外 还可以省略 t3 变量，因为 t2 可以复用。

``
t2 = index + 4
t2 = t2 * 8
array[index] = t2
```

#### 目标代码优化

选择合适的寻址方式，使用位移代替乘法，删除多余的指令

## 类对象所占用的内存

```cpp
class A {
public:
};

int main() {
    A a;
    cout << sizeof(a) << endl; // 1
    return 0;
}
```
**一个空类 sizeof(a) 的结果是 1**。因为对象是有地址的。内存中的一个地址单元**里面存的是 1 个字节的内容**

```cpp
class A {
public:
    void func1();
    void func2();
    
};

int main() {
    A a;
    cout << sizeof(a) << endl; // 1
    return 0;
}
```

**类中的成员函数是不占用类对象内存空间的**。

```cpp
class A {
public:
    int a = 1;
    void func1();
    void func2();
    
};

int main() {
    A a;
    cout << sizeof(a) << endl; // 4
    return 0;
}
````

**成员变量是包含在每个对象中，占字节的**

```cpp
class A {
public:
    int a = 1;
    void func1() {
        int a = 2;
    }
    void func2();
    
};

int main() {
    A a;
    cout << sizeof(a) << endl; // 4
    return 0;
}
```

**成员函数不占类对象的字节空间**

```cpp
class A {
public:
    virtual void fun3();
    
};

int main() {
    cout << sizeof(A) << endl; // 8
    return 0;
}
```

**类中如果有一个虚函数，对象的 sizeof 会增加 4 个字节**，因为这个类会有一个指向虚函数的指针。（但是我在 Linux 和 MacBook 测试是 8）

> 注意： sizeof(a)的返回值是一个无符号整数十进制的值，即 unsigned_int, 并不是 int 类型

静态成员变量不计算在对象的 sizeof 内

> 空类 `sizeof(a) = 1`    
> 成员函数不占类的内存空间      
> 成员变量是占字节空间的      
> 虚函数占用 4 个字节

## `A a`和`A *aa = new A()`区别

唯一的区别就是` A a` 的 a 是在栈上申请的空间，`A * aa = new A()` 是在堆上申请的空间，a 退出作用范围后，自动析构了！

而  aa 没有析构，需要人为的调用`delete aa`来析构`aa`。使用时没有区别！

```cpp
class A {
public:
    A() {
        cout << "A的构造函数" << endl;
    }
    int bb = 10;
};

class B : public A{
public:
    B() {
        cout << "B的构造函数" << endl;
    }
};

int main() {
    A *a = nullptr;    //不会调用构造函数
    // cout << a->bb << endl;  //报错
    cout << "------------------" << endl;
    A *ab = new B();   //先调用A的构造函数再调用B的构造函数
    cout << "------------------" << endl;
    B *bb = new B();
    cout << "------------------" << endl;
    B *b;             //不会调用构造函数
    return 0;
}
```

输出：

```
------------------
A的构造函数
B的构造函数
------------------
A的构造函数
B的构造函数
------------------
```
