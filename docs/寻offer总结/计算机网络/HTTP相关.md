
<font color="green" size=4>更多读书笔记关注公众号:**零K同学**<font>

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-02/公众号二维码.75dvf969t4w0.png)


- [OSI与TCP/IP各层结构](#osi与tcpip各层结构)
- [DNS 是什么](#dns-是什么)
  - [DNS 的工作原理](#dns-的工作原理)
  - [DNS查询方式有哪些？](#dns查询方式有哪些)
  - [`DNS`解析过程](#dns解析过程)
  - [为什么域名解析用`UDP`协议？](#为什么域名解析用udp协议)
  - [为什么 DNS 区域传送用TCP协议](#为什么-dns-区域传送用tcp协议)
- [**说一下HTTP协议**](#说一下http协议)
- [HTTP常见状态码](#http常见状态码)
- [HTTP常见字段](#http常见字段)
- [GET 和 POST 的区别](#get-和-post-的区别)
- [HTTP 的特性(优缺点)](#http-的特性优缺点)
  - [HTTP怎么解决无状态问题](#http怎么解决无状态问题)
  - [cookie 技术](#cookie-技术)
  - [什么是`Session` 机制](#什么是session-机制)
  - [`Cookie`和 `Session`有什么区别](#cookie和-session有什么区别)
- [HTTP/1.1 的性能如何](#http11-的性能如何)
- [`HTTP`长连接和短连接的区别](#http长连接和短连接的区别)
- [`http/1.0`和`http/1.1`的区别](#http10和http11的区别)
- [http1.1 长连接怎么判断一个请求已经结束](#http11-长连接怎么判断一个请求已经结束)
- [`HTTP` 和 `HTTPS`的区别](#http-和-https的区别)
- [HTTPS 如何采用混合加密方式的](#https-如何采用混合加密方式的)
- [SSL/TLS 建立过程(握手过程)](#ssltls-建立过程握手过程)
  - [为什么 SSL 的握手是 4 次](#为什么-ssl-的握手是-4-次)
- [RSA 算法的缺陷](#rsa-算法的缺陷)
- [数字证书](#数字证书)
- [HTTP1.1 不足](#http11-不足)
- [HTTP 1.1 协议的优化](#http-11-协议的优化)
- [HTTP2 相对于 HTTP1 做了哪些提升](#http2-相对于-http1-做了哪些提升)
- [在浏览器中输入`URL`后执行的全部过程](#在浏览器中输入url后执行的全部过程)
  - [详细说这个过程](#详细说这个过程)
- [一个`TCP`可以对应几个`HTTP`请求](#一个tcp可以对应几个http请求)
- [一个 `TCP` 连接中 `HTTP` 请求可以一起发送么](#一个-tcp-连接中-http-请求可以一起发送么)
- [为什么有的时候刷新页面不需要重新建立 SSL 连接](#为什么有的时候刷新页面不需要重新建立-ssl-连接)
- [浏览器对同一 `Host` 建立 `TCP` 连接到数量有没有限制](#浏览器对同一-host-建立-tcp-连接到数量有没有限制)

---------

## OSI与TCP/IP各层结构

- OSI的分层(7层)：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
- TCP/IP(4层)：数据链路层、网络层、传输层、应用层
- 五层协议(5层)：物理层、数据链路层、网络层、运输层、应用层

每一层的作用：

- 物理层：负责底层数据传输，就是为数据链路层提供二进制传输服务。如网线；网卡标准。 （比特`Bit`）

- 数据链路层：接收来自物理层的数据，并封装成帧，传送到网络层；如网卡`MAC`地址。（帧Frame），ARP，STP

- 网络层：定义`IP`编址，定义路由选择功能；实现主机与主机之间的通信，如不同设备的数据转发。（包Packet），IP，ICMP

- 传输层：主要负责端到端之间传输数据；如 `TCP`、`UDP`。（段 Segments）

- 会话层：负责在网络中的两节点之间建立、维持和终止通信；如一个软件的数据分发给另一个软件。

- 表示层：数据格式标识，基本压缩加密功能。

- 应用层：各种应用软件，包括 `Web` 应用。HTTP，HTTPS，DNS，RTMP、FTP



## DNS 是什么

DNS（Domain Name System）是域名解析系统，就是在因特网上作为域名和IP地址相互映射的分布式数据库系统，能够使用户更方便的去访问互联网，而不用去记住一连串数字的`IP`地址。

通过主机名最终得到这个主机名对应的`IP`地址，这个过程就做**域名解析**

通俗的说就是我们更习惯去记住一个网站的名字而不是这个网站的`IP`地址，比如`www.baidu.com`,而不是记住它的`ip`地址，比如：`167.23.10.2`。

### DNS 的工作原理

将主机域名转换为`ip`地址，属于**应用层协议**，使用`UDP`传输。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/dns-01.5hnf2qy1yyw0.png)

`DNS`解析有两种方式：**递归查询**和**迭代查询**

一、主机 向 本地域名服务器的查询一般都是采用**递归查询**。<br>
二、本地域名服务器 向 根域名服务器的查询的**迭代查询**。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结02/DNS查询图解.7jshddthzvo0.png)

### DNS查询方式有哪些？

- 递归解析

当局部`DNS`服务器自己不能回答客户机的`DNS`查询时，它就需要向其他`DNS`服务器进行查询。**一般是先向该域名的根域名服务器查询，再由根域名服务器一级级向下查询**。最后得到的查询结果返回给局部`DNS`服务器，再由局部`DNS`服务器返回给客户端。

- 迭代解析

局部`DNS`服务器不是自己向其他`DNS`服务器进行查询，**而是把能解析该域名的其他`DNS`服务器的`IP`地址返回给客户端`DNS`程序**，客户端`DNS`程序再继续向这些`DNS`服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：`baidu.com`的服务器`ip`地址在`192.168.4.5`这里，你自己去查吧。

### `DNS`解析过程

- 客户机提出域名解析请求，并将该请求发送给本地的域名服务器。

- 当本地的域名服务器收到请求后，就先查询本地的缓存，如果有该记录项，则本地的域名服务器就直接把查询的结果返回。
  
- 如果没有，就到互联网中根服务器去查找，获取`.com`的顶级域名服务器

- 然后在`.com`的顶级域名服务器中进行查找，比如说获取`google.com`的授权域名服务器

- 在`google.com`的授权域名服务器中查找主机`www.google.com`的`IP`地址，最后将`IP`地址返回给计算机。

- 计算机获得`www.google.com`的`IP`地址后，用户就可以访问这个网站了。

### 为什么域名解析用`UDP`协议？

因为`UDP`快啊！`UDP`的`DNS`协议只要一个请求、一个应答就好了。

而使用基于`TCP`的`DNS`协议要三次握手建立连接、然后再进行发送数据，最后通过四次挥手关闭连接，但是`UDP`协议传输内容不能超过`512`字节。

不过客户端向`DNS`服务器查询域名，一般返回的内容都不超过`512`字节，所以用`UDP`传输即可。

一般`DNS`区域传送用的才是`TCP`协议

### 为什么 DNS 区域传送用TCP协议

> 区域传送是指将一个区域文件复制到多个`DNS`服务器的过程<br>
> `DNS`主从复制，就是将主`DNS`服务器的解析库复制传送至从`DNS`服务器，进而从服务器就可以进行正向、反向解析了.

因为`TCP`协议可靠性好啊！

因为你要从主`DNS`上复制内容，肯定要保证可靠性啊，`UDP`是不保证传输的可靠性的。

还有，`TCP`协议的传输内容比较大，`UDP`要求传输的内容不能超过`512`字节，如果同步的数据超过`512`那肯定不行呀。

所以用`TCP`协议比较好。


## **说一下HTTP协议**

`HTTP`协议属于**应用层**协议，超文本传输协议，端口号是`80`。`HTTP`协议被用于网络中两台计算机间的通信，*浏览器根据从服务器得到的`HTTP`响应体中分别得到报文头，响应头和信息体（`HTML`正文等），之后将`HTML`文件解析并呈现在浏览器上。*



## HTTP常见状态码

```
100 ：服务器已经接收到一部分请求，等待其余部分
200 ：请求成功，成功返回网页
206 ：HTTP分块下载或者断点续传，返回数据的一部分而不是全部
301 ：资源（网页等）被永久转移到其它 URL
302 ：资源（网页等）被临时转移到其它 URL
401 ：未授权，需要身份验证
403 ：服务器拒绝请求
404 ：请求的网页或资源不存在
500 ：内部服务器错误，无法完成请求
502 ：错误网关
503 ：服务器无法使用，服务器临时过载或宕机
504 ：网关超时
```

1xx：指示信息--表示请求已接收，继续处理。

2xx：成功--表示请求已被成功接收、理解、接受。

3xx：重定向--要完成请求必须进行更进一步的操作。

4xx：客户端错误--请求有语法错误或请求无法实现。

5xx：服务器端错误--服务器未能实现合法的请求。

## HTTP常见字段

- Host: 客户端发送请求时，用来指定服务器的域名。有了`host`字段，就可以将请求发往**同一台服务器上的不同网站**了。`Host: www.AAA.com'`
- Content-Length: 表示服务器返回的数据长度
- Connection: `HTTP/1.1` 默认是持久连接，但是为了兼容老版本的 HTTP，需要制定 Connection 首部字段的值为 Keep-alive，简单说就是实现长连接，实现 TCP 复用
- Content-Type: 告诉客户端，本次数据是什么格式，也就是数据类型。
- Content-Encoding: 表示服务器返回的数据用了什么压缩方法，比如：gzip。


## GET 和 POST 的区别

1. `get`是从服务器上获取数据，`post`向服务器传送数据

2. `get`把请求的数据放在`url`上， 以`?`分割`URL`和传输数据，参数之间以`&`相连，所以`get`不太安全。而`post`把数据放在`HTTP`的包体内（`requrest body`）

3. `get`提交的数据最大是`2k`（ 限制实际上取决于浏览器）， `post`理论上没有限制。

4. `GET`产生一个`TCP`数据包，浏览器会把`http header`和`data`一并发送出去，服务器响应`200`(返回数据); `POST`产生两个`TCP`数据包，浏览器先发送`header`，服务器响应`100 continue`，浏览器再发送`data`，服务器响应`200 ok`(返回数据)。

5. `GET`请求会被浏览器主动缓存，而`POST`不会，除非手动设置。

6. 本质区别：`GET`是幂等的，而`POST`不是幂等的

   > 这里的幂等性：多次执行操作结果是系统的。就是为了保证请求方法不会破坏服务器上的资源。

  `GET`方法是安全幂等且幂等的，因为它是**只读**操作，无论操作多少次，服务器上的数据都是安全的，且每次返回的结果也是相同的。

## HTTP 的特性(优缺点)

- HTTP 的特点就是简单，容易扩展，而且支持跨平台

- HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式

- HTTP协议里的各类请求方法、`URI/URL`、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充

- HTTP 的缺点是无状态，明文传输，缺乏安全性

- 不过无状态也是有好处的，能够减少服务器的负担


### HTTP怎么解决无状态问题

### cookie 技术

cookie 技术可以用来解决 HTTP 请求和相应无状态问题，相当于客户端第一次请求后，服务器会下发一个装有客户端信息的[小贴纸],后续客户端请求服务器的时候，带上这个[小贴纸]，服务器就能认得了了。

`Cookie` 一般用来保存用户信息 比如在 `Cookie` 中保存已经登录过得用户信息，下次访问网站的时候就会自动帮你登陆。

一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 `Token` 在 `Cookie` 中，下次登录的时候只需要根据 `Token` 值来查找用户即可(为了安全考虑，重新登录一般要将 `Token` 重写)；

### 什么是`Session` 机制

也可以**使用`Session` 机制来解决 HTTP 无状态这个问题**，

- `Session` 的主要作用**就是通过服务端记录用户的状态**。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 `HTTP` 协议是无状态的。服务端给特定的用户创建特定的 `Session` 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 `Session`，过了时间限制，就会销毁这个`Session`）。

> - 在服务端保存 `Session` 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库`redis`保存)。既然 `Session` 存放在服务器端，   

- 那么我们**如何实现 `Session `跟踪呢**？

大部分情况下，我们都是通过在 `Cookie` 中附加一个 `Session ID` 来方式来跟踪。

### `Cookie`和 `Session`有什么区别

`Cookie` 和 `Session`都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

- 》》》说上面的

- `Cookie` 数据保存在客户端(浏览器端)`，Session` 数据保存在服务器端。

- `Cookie` 存储在客户端中，而`Session`存储在服务器上，相对来说 `Session` 安全性更高。如果使用 `Cookie` 携带一些敏感信息不要直接写入 `Cookie` 中，最好能将 `Cookie` 信息加密然后使用到的时候再去服务器端解密。

##  HTTP/1.1 的性能如何
## `HTTP`长连接和短连接的区别
## `http/1.0`和`http/1.1`的区别

- **长连接**

早期 `HTTP/1.0` 性能上的一个很大的问题，那就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无谓的 TCP 连接建立和断开，增加了通信开销。

为了解决上述 TCP 连接问题，`HTTP/1.1` 提出了**长连接**的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开 所造成的额外开销，减轻了服务器端的负载。

持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

**长连接和短连接的适用场景**：

- 短连接：适用于网页浏览等数据刷新频度较低的场景。

- 长连接：适用于客户端和服务端通信频繁的场景，例如聊天室，实时游戏等

- **管道传输**

也就是可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。

但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。

> 因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会导致客户端一直请求不到数据，这也就是「队头阻塞」

## http1.1 长连接怎么判断一个请求已经结束

- 如果是短连接，没有启用 `keepalive`，则可以通过是否关闭了连接来判断是否传输结束，即在读取时可判断 `read() != -1`。

- 如果是长连接，先读请求头，一直到 `\r\n\r\n` 说明请求头结束，然后解析 http 头，如果 `Content-Length=x` 存在，则就知道 `http` 响应的长度为 x 。直接读取 x 字节就是响应内容。

- 如果 `Content-Length=x` 不存在，那么头类型为 `Transfer-Encoding: chunked` 说明响应的长度不固定，则在响应头结束后标记第一段流的长度

## `HTTP` 和 `HTTPS`的区别

- HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 `SSL/TLS` 安全协议，使得报文能够加密传输。
- HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
- HTTP 的端口号是 80，HTTPS 的端口号是 443。
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

- `HTTPS`协议[**使用混合加密和摘要算法**]解决了`HTTP`协议的一些不足，因为 `HTTP`：
  - 1.通信使用明文（不加密），内容可能会被盗取
  - 2.不验证通信方身份，因此可能遭遇伪装
  - 3.无法证明报文的完整性（即准确性），所以可能已遭篡改      

> HTTP+加密+认证+完整性保护=HTTPS

由`HTTP`升级为`HTTPS`需要到 `CA` 申请证书，一般免费证书较少，因此需要一定费用

## HTTPS 如何采用混合加密方式的

- 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
- 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。

采用「混合加密」的方式的原因：

- 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- 非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢

## SSL/TLS 建立过程(握手过程)

- 第一次握手：客户端会向到服务端发送一个 Client Hello 的消息，这个消息中有 客户端使用的 TLS 版本号，支持的密码套件，以及生成的随机数

- 第二次握手：当服务端收到 Client Hello 消息后，会确认 TLS 是否支持，从密码套件列表中选择一个密码套件，以及生成随机数。接着返回 Server Hello 消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数，还有从客户端的密码套件中选出的 密码套件。同时包含 CA 数字证书。

- 第三次握手：客户端检查 CA 数字证书的真实性，如果是有效的，客户端会生成一个随机数，用服务器的 RSA 公钥加密这个随机数，然后传给服务端，服务端收到之后用 RSA 私密进行解密，得到客户端的随机数。

- 第四次握手：服务器也是同样的操作，如果双方都验证加密和解密没有问题，那么握手就完成了。

> 1.Client --> TLS版本号，密码套件列表，随机数 --> Server   
> 2.Server --> TLS版本号，密码套件，随机数，CA --> Client     
> 3.检查CA真实性，生成随机数，客户端用 RSA 公钥加密，服务端用 RSA 私钥解密    
> 4.服务器同样操作

### 为什么 SSL 的握手是 4 次

SSL/TLS 1.2 需要 4 次握手，需要 2 个 RTT 的时延，但是再 SSL/TLS 1.3 优化了过程，只需要 1 个 RTT 往返时延，也就是只有 3 次握手


## RSA 算法的缺陷

使用 RSA 密钥协商算法的最大问题是不支持前向保密。因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。

为了解决这一问题，于是就有了 **DH 密钥协商算法**

客户端和服务端各自会生成随机数，并以此作为私钥，然后根据公开的 DH 计算公式算出各自的公钥，通过 TLS 握手双方交换各自的公钥，这样双方都有自己的私钥和对方的公钥，然后双方根据各自持有的材料算出一个随机数，这个随机数的值双方都是一样的，这就可以作为后续对称加密时使用的密钥。

DH 密钥交换过程中，即使第三方截获了 TLS 握手阶段传递的公钥，在不知道的私钥的情况下，也是无法计算出密钥的，而且每一次对称加密密钥都是实时生成的，实现前向保密。

## 数字证书

客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

但是这里存在一个问题，如何保证公钥不被篡改。

所以就需要借助 **CA** （数字证书认证机构），将服务器公钥放在数字证书中，保证公钥的可信。

- 首先是服务器把自己的公钥注册到 CA
- CA 用自己的私钥将服务器的公钥弄成数字签名，并颁发数字证书
- 然后服务器将 服务器的公钥和 CA 的数字签名(组成**数字证书**)发送给客户端
- 客户端拿到服务器的数字证书后，使用 CA 的公钥确认数字证书的真实性
- 如果确定是真实后就用公钥加密信息成密文后发送给服务端
- 服务端用私钥进行解密 

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QvJUU4JUFFJUExJUU3JUFFJTk3JUU2JTlDJUJBJUU3JUJEJTkxJUU3JUJCJTlDL0hUVFAvMjItJUU2JTk1JUIwJUU1JUFEJTk3JUU4JUFGJTgxJUU0JUI5JUE2JUU1JUI3JUE1JUU0JUJEJTlDJUU2JUI1JTgxJUU3JUE4JThCLnBuZw?x-oss-process=image/format,png)

## HTTP1.1 不足

- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；
- 服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据，也就是**队头阻塞**；
  - HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。
  - 移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。
- 请求只能从客户端开始，服务器只能被动响应

------

##  HTTP 1.1 协议的优化

- 第一个思路是，**通过缓存技术来避免发送 HTTP 请求**

客户端收到第一个请求的响应后，可以将其缓存在本地磁盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。服务器在发送 HTTP 响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求。

> 那缓存是如何做到的呢？

> 客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。

> 这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，如果找到了，就直接从本地读取该响应。读取本次磁盘的速度肯定比网络请求快得多.


- 第二个思路是，**减少 HTTP 请求的次数**，有以下的方法：

  - **减少重定向请求次数**：如果服务器上一个资源从 URL1 迁移到 URL2，但是客户端不知情还访问 URL1，这时候服务端会返回一个 302 响应码和 Location 头部，告诉客户端该资源已经迁移至 url2 了，于是客户端需要再发送 url2 请求以获得服务器的资源。
  - **合并请求**：把多个访问小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少请求，也就意味着减少了重复发送的 HTTP 头部。进而减少 TCP 连接的数量，因而省去了 TCP 握手和慢启动过程耗费的时间。


- 第三思路是，**通过压缩响应资源，降低传输资源的大小，**从而提高传输效率，所以应当选择更优秀的压缩算法。


> 缓存--避免 HTTP 请求，重定向和合并请求--减少 HTTP 请求，压缩相应资源

-------

## HTTP2 相对于 HTTP1 做了哪些提升

第一点，对于常见的 HTTP 头部通过静态表和 Huffman 编码的方式，将体积压缩了近一半，而且针对后续的请求头部，还可以建立动态表，将体积压缩近 90%，大大提高了编码效率，同时节约了带宽资源。

不过，动态表并也非可以无限增大， 因为动态表是会占用内存的，动态表越大，内存也越大，容易影响服务器总体的并发能力，因此服务器需要限制 HTTP/2 连接时长或者请求次数。

第二点，**HTTP/2 实现了 Stream 并发**，多个 Stream 只需复用 1 个 TCP 连接，节约了 TCP 和 TLS 握手时间，以及减少了 TCP 慢启动阶段对流量的影响。不同的 Stream ID 才可以并发，即使乱序发送帧也没问题，但是同一个 Stream 里的帧必须严格有序。

另外，可以根据资源的渲染顺序来设置 Stream 的优先级，从而提高用户体验。

第三点，服务器支持主动推送资源，大大提升了消息的传输性能，服务器推送资源时，会先发送 PUSH_PROMISE (push_promise )帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。

>  `HTTP/2` 通过 Stream 的并发能力，解决了 `HTTP/1`队头阻塞的问题，

> 但是 HTTP/2 还是存在“队头阻塞”的问题，只不过问题不是在 HTTP 这一层面，而是在 TCP 这一层。   
> HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。

> 这个问题在 `HTTP/3` 协议解决了，因为这是 TCP 协议自身的问题，直接放弃 TCP 协议，转而使用 UDP 协议作为传输层协议

> 记忆：    
> 1.头部通过 静态表 和 Huffman 编码的方式减少体积  ，还可以建立动态表（也不是无限大）      
> 2.HTTP/2 实现了 Stream 并发，解决了 `HTTP/1`队头阻塞的问题，减少 tcp 握手，同一个 ID 可以乱序并发    
> 3.服务器支持主动推送资源，发出 push_promise 帧      
> 4.解决头部阻塞问题


--------

## 在浏览器中输入`URL`后执行的全部过程

1. 首先是域名解析，客户端使用`DNS`协议将`URL`解析为对应的`IP`地址；

2. 然后建立`TCP`连接，客户端与服务器通过三次握手建立`TCP`连接；
   
3. 接着是`http`连接，客户端向服务器发送`http`连接请求； （`http`连接无需额外连接，直接通过已经建立的`TCP`连接发送）
   
4. 服务器对客户端发来的`http`请求进行处理，并返回响应；
   
5. 客户端接收到`http`响应，将结果渲染展示给用户。

![](./img/输入url.png)


### 详细说这个过程

- **1、解析 URL**

首先浏览器做的第一步工作就是要对 URL 进行解析，从而产生发送给 Web 服务器的请求信息，

对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。

- **生成 HTTP 请求信息**

对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。

- **DNS 域名解析**

通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。

但在发送之前，还需要进行 DNS 域名解析，就是**查询服务器域名对应的 IP 地址**

- **协议栈**

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。

应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，它们两会接受应用层的委托执行收发数据的操作。

协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据刽被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。

此外 IP 中还包括 ICMP 协议和 ARP 协议。

    1）ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。
    
    2）ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。

- **TCP** 

HTTP 是基于 TCP 协议传输的，TCP 传输数据之前，要先三次握手建立连接，

- **IP**

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。

在 IP 协议里面需要有**源地址 IP**和 **目标地址 IP**：

1）源地址IP，即是客户端输出的 IP 地址；

2）目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。

这个时候就需要根据**路由表**规则，来判断哪一个网卡作为源地址 IP

- 然后生成 IP 头部，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。

- 接下来需要 ARP 协议帮我们找到路由器的 MAC 地址

ARP 协议会在以太网中以广播的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。

然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。

- 接着就到网卡、交换机、路由器

- 最终到达服务器

服务器会一次解析 Mac 头部，IP 头部，TCP 头部，TCP 头部里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。

服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程

HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址

然后按照相同的方式返回给客户端，客户端收到 HTTP 响应报文之后就可以渲染给用户了。

- 最后客户端向服务器发起了 TCP 四次挥手，至此双方的连接就断开了

-------

## 一个`TCP`可以对应几个`HTTP`请求

从上面的分析可知，如果维持连接，一个 `TCP` 连接是可以发送多个 `HTTP` 请求的。


## 一个 `TCP` 连接中 `HTTP` 请求可以一起发送么

`HTTP/1.1` 存在一个问题，单个 `TCP` 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠。

虽然 `HTTP/1.1` 规范中规定了 `Pipelining` 来试图解决这个问题，但是这个功能在浏览器中默认是关闭的。所以可以认为这是不可行的。

在 `HTTP2` 中由于 `Multiplexing`（多路技术） 特点的存在，多个 `HTTP` 请求可以在同一个 `TCP` 连接中并行进行。

那么在 `HTTP/1.1` 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：

- 维持和服务器已经建立的 `TCP` 连接，在同一连接上顺序处理多个请求。
- 和服务器建立多个 `TCP` 连接。

> 单个 TCP 同一时刻只能处理一个请求，Pipelining 可以解决这个问题，但是浏览器默认是关闭的，HTTP2 有 Multiplexing 多路技术      
> 多个 HTTP 可以在同一 TCP 上并行进行

## 为什么有的时候刷新页面不需要重新建立 SSL 连接

在第一个问题的讨论中已经有答案了，`TCP` 连接有的时候会被浏览器和服务端维持一段时间。`TCP` 不需要重新建立，`SSL` 自然也会用之前的。

## 浏览器对同一 `Host` 建立 `TCP` 连接到数量有没有限制

假设我们还处在 `HTTP/1.1` 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 `TCP` 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 `TCP` 连接发 `HTTP` 请求，那电脑或者服务器都可能受不了，要是有 `1000` 张图片的话总不能开 `1000` 个`TCP` 连接吧，你的电脑同意 `NAT` 也不一定会同意。

**有。`Chrome` 最多允许对同一个 `Host` 建立六个 `TCP` 连接。不同的浏览器有一些区别。**

如果请求都是 `HTTPS` 连接并且在同一个域名下，那么浏览器在 `SSL` 握手之后会和服务器商量能不能用 `HTTP2`，如果能的话就使用 `Multiplexing` 功能在这个连接上进行多路传输。*不过也未必会所有挂在这个域名的资源都会使用一个 `TCP` 连接去获取，但是可以确定的是 `Multiplexing` 很可能会被用到。*

如果发现用不了 `HTTP2` 呢？或者用不了 `HTTPS`（现实中的 `HTTP2` 都是在` HTTPS` 上实现的，所以也就是只能使用 `HTTP/1.1`）。那浏览器就会在一个 `HOST` 上建立多个 `TCP` 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求。

如果所有的连接都正在发送请求呢？那其他的请求就只能等了。

> 谷歌浏览器支持 6 个连接   
> 如果支持使用 HTTPS，就可以使用 multiplexing 功能进行多路传输，如果使用不了，那么浏览器只能一个 host 建立多个 tcp 连接了。

