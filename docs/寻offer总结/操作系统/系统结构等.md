
<font color="green" size=4>更多读书笔记关注公众号:**零K同学**<font>

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-02/公众号二维码.75dvf969t4w0.png)

- [冯诺依曼模型](#冯诺依曼模型)
  - [常⻅的寄存器种类](#常的寄存器种类)
  - [总线](#总线)
- [程序执行的基本过程](#程序执行的基本过程)
- [虚拟内存](#虚拟内存)
- [操作系统如何管理虚拟地址与物理地址(内存分段与内存分页)](#操作系统如何管理虚拟地址与物理地址内存分段与内存分页)
- [分段机制下，虚拟地址和物理地址是如何映射的](#分段机制下虚拟地址和物理地址是如何映射的)
- [分段为什么会产生内存碎片的问题？](#分段为什么会产生内存碎片的问题)
  - [使用内存交换解决外部内存碎片](#使用内存交换解决外部内存碎片)
  - [分段为什么会导致内存交换效率低的问题](#分段为什么会导致内存交换效率低的问题)
- [分页是怎么解决分段的内存碎片、内存交换效率低的问题](#分页是怎么解决分段的内存碎片内存交换效率低的问题)
- [分页机制下，虚拟地址和物理地址是如何映射的？](#分页机制下虚拟地址和物理地址是如何映射的)
  - [简单的分页有什么缺陷吗？](#简单的分页有什么缺陷吗)
- [段页式内存管理](#段页式内存管理)
- [Linux 内存管理](#linux-内存管理)
  - [Linux 的虚拟地址空间是如何分布的](#linux-的虚拟地址空间是如何分布的)
- [内存页面置换算法](#内存页面置换算法)
  - [什么是缺页异常（缺页中断）](#什么是缺页异常缺页中断)
  - [最佳页面置换算法](#最佳页面置换算法)
  - [先进先出置换算法](#先进先出置换算法)
  - [最近最久未使用的置换算法](#最近最久未使用的置换算法)
  - [时钟页面置换算法](#时钟页面置换算法)
  - [最不常用算法](#最不常用算法)
- [虚拟技术你了解吗？](#虚拟技术你了解吗)
- [内存的覆盖是什么，有什么特点](#内存的覆盖是什么有什么特点)


------

## 冯诺依曼模型

冯诺依曼“约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是中央处理器（CPU）、内存、输入设备、输出设备、总线。

中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据:
- 32 位 CPU 一次可以计算 4 个字节;
- 64 位 CPU 一次可以计算 8 个字节;

CPU 内部还有一些组件，常⻅的有**寄存器**、**控制单元**和**逻辑运算单元**等。其中，控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。

### 常⻅的寄存器种类

- 通用寄存器，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。 
- 程序计数器，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。
- 指令寄存器，用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储
  在这里。

### 总线

总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种:

- 地址总线，用于指定 CPU 将要操作的内存地址; 
- 数据总线，用于读写内存的数据;
- 控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线;

当 CPU 要读写内存数据的时候，一般需要通过两个总线: 

- 首先要通过「地址总线」来指定内存的地址;
- 再通过「数据总线」来传输数据;

## 程序执行的基本过程


程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。

- 第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」
- 第二步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把 指令交给「逻辑运算单元」运算;如果是存储类型的指令，则交由「控制单元」执行;
- 第三步，CPU 执行完指令后，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数 器」的值会自增 4;

> 简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令⻓度自增，开始顺序读取下一条指令。
>
> CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个 不断循环的过程被称为 CPU 的指令周期。


-----

## 虚拟内存

**虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。**

如果`CPU`直接去操作操作系统的内存，也就是物理内存，在这种情况下，要想在内存中同时运行多个程序是不可能的，就比如 如果一个程序要向在`002`这个位置上写入一个新的值，那么就会覆盖掉上一个程序在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。

操作系统为每一个进程分配一套独立的**虚拟地址**，各个程序操作自己的地址，互不干涉，但是有个前提就是每个进程不能直接访问物理地址。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/虚拟内存01.if9p8l54eag.png)

操作系统就是提供一种这样的机制，**将不同进程的虚拟地址和不同内存的物理地址映射起来。**

如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。


> - 我们程序所使用的内存地址叫做**虚拟内存地址**（Virtual Memory Address）
> - 实际存在硬件里面的空间地址叫**物理内存地址**（Physical Memory Address）。


操作系统引入了虚拟内存，进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存，


## 操作系统如何管理虚拟地址与物理地址(内存分段与内存分页)

主要有两种方式，分别是**内存分段**和**内存分页**

- <font color="orange" font-weight=bolder size = 4>内存分段</font>

程序是由若干个逻辑分段组成的，比如有 代码分段、数据分段、栈段、堆段。**不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来**。


- <font color="orange" font-weight=bolder size = 4>内存分页</font>

分段的好处就是能产生连续的内存空间，但是会出现**内存碎片**和**内存交换的空间太大**的问题。

要解决这些问题，就有了**内存分页**（Paging）。

分页是**把整个虚拟内存和物理内存空间切成一段段固定尺寸的大小**。这样一个连续并且尺寸固定的内存空间，我们叫**页**（`Page`）。在 `Linux` 下，每一页的大小为 `4KB`。

虚拟地址与物理地址之间通过**页表**来映射，如下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存分页01.2waeymf4hwk.png)

页表实际上存储在 `CPU` 的内存管理单元（`MMU`） 中，于是 `CPU` 就可以直接通过 `MMU`，找出要实际要访问的物理内存地址。

而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

## 分段机制下，虚拟地址和物理地址是如何映射的

分段机制下的虚拟地址由两部分组成，**段选择因子**和**段内偏移量**。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存分段01.1hsltcfttpa8.png)

- **段选择因子**就保存在段寄存器里面。段选择因子里面最重要的是**段号**，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等

- 虚拟地址中的**段内偏移量**应该位于 `0` 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：

- 第一个就是内存碎片的问题。
- 第二个就是内存交换的效率低的问题。

## 分段为什么会产生内存碎片的问题？

举个例子，假设有 `1G` 的物理内存，用户执行了多个程序，其中：

- 游戏占用了 512MB 内存
- 浏览器占用了 128MB 内存
- 音乐占用了 256 MB 内存。

这个时候，如果我们关闭了浏览器，则空闲内存还有 `1024 - 512 - 256 = 256MB`。

如果这个 `256MB` 不是连续的，被分成了两段 `128 MB` 内存，这就会导致没有空间再打开一个 `200MB` 的程序。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存分段03.4ukry7t7qgs0.png)

这里的内存碎片的问题共有两个地方：

- 外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；
- 内部内存碎片，程序所有的内存都被装载到了物理内存，但是这个程序有部分的内存可能并不是很常使用，这也会导致内存的浪费；

### 使用内存交换解决外部内存碎片

可以把音乐所占用的不连续的内存写到磁盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 `512MB` 内存后面。这样就能空缺出连续的 `256MB` 空间，于是新的 `200MB` 程序就可以装载进来。

### 分段为什么会导致内存交换效率低的问题

对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。

因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。

所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。

为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。


## 分页是怎么解决分段的内存碎片、内存交换效率低的问题

由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而**采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。**

如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。

## 分页机制下，虚拟地址和物理地址是如何映射的？

在分页机制下，虚拟地址分为两部分，**页号**和**页内偏移**。页号就是页表的索引，页表中的物理页号字段保存着每一页的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存分页03.3v4z7vjlwdc0.png)

对于一个内存地址转换，其实就是这样三个步骤：

- 把虚拟内存地址，切分成页号和偏移量；
- 根据页号，从页表里面，查询对应的物理页号；
- 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。

**虚拟内存中的页通过页表映射为物理内存中的页**，如下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存分页04.2auvuajdvge8.png)


### 简单的分页有什么缺陷吗？

**有空间上的缺陷**。

因为操作系统是可以同时运行非常多的进程的，这样的话就会导致页表非常大。

就比如在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 4MB 的内存来存储页表。

那么，100 个进程的话，就需要 400MB 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。

## 段页式内存管理

内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，就是**段页式内存管理**。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/段页式内存管理01.3m41p0tx48o0.png)

- 先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；

- 接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；

这样，地址结构就**由段号、段内页号和页内位偏移**三部分组成。

对于段页式内管管理机制来说，每个程序对应一个段表，然后每一段对应一张段页表，段表中的页表地址就是页表的起始地址，段页表中保存了物理页号。物理页号加上页内偏移就是物理地址了。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/段页式内存管理02.2j8h9qa772q0.png)

段页式内存管理的虚拟地址和物理地址的映射需要经过**三次内存访问**：

- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号；
- 第三次将物理页号与页内位移组合，得到物理地址。

我们可以用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。

段页式内内存管理的虚拟地址和物理地址的映射需要经过**三次内存访问**：

- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号；
- 第三次将物理页号与页内位移组合，得到物理地址。

我们可以用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。


## Linux 内存管理

**Linux 内存主要采用的是分页式内存管理，但同时也不可避免地涉及了分段机制。**

Linux 系统中的每个段都是从 0 地址开始的），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。

### Linux 的虚拟地址空间是如何分布的

在 Linux 操作系统中，虚拟地址空间的内部又被分为**内核空间**和**用户空间**两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/Linux虚拟内存01.2xaz881vezi0.png)

通过这里可以看出：

- 32 位系统的内核空间占用 1G，位于最高处，剩下的 3G 是用户空间；
- 64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。


-----

## 内存页面置换算法

### 什么是缺页异常（缺页中断）

当 CPU 访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存。那它与一般中断的主要区别在于：

- 缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号。
- 缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。

缺页中断的处理流程:

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/缺页字段01.3cmrr0n9o280.png)

- 1.在 CPU 里访问一条 Load M 指令，然后 CPU 会去找 M 所对应的页表项。
- 2.如果该页表项的状态位是「有效的」，那 CPU 就可以直接去访问物理内存了，如果状态位是「无效的」，则 CPU 则会发送缺页中断请求。
- 3.操作系统收到了缺页中断，则会执行缺页中断处理函数，先会查找该页面在磁盘中的页面的位置。
- 4.找到磁盘中对应的页面后，需要把该页面换入到物理内存中，但是在换入前，需要在物理内存中找空闲页，如果找到空闲页，就把页面换入到物理内存中。
- 5.页面从磁盘换入到物理内存完成后，则把页表项中的状态位修改为「有效的」。
- 6.最后，CPU 重新执行导致缺页异常的指令。

上面所说的过程，第 4 步是能在**物理内存找到空闲页的情况，那如果找不到呢**？

找不到空闲页的话，就说明此时内存已满了，这时候，就需要「页面置换算法」选择一个物理页，如果该物理页有被修改过（脏页），则把它换出到磁盘，然后把该被置换出去的页表项的状态改成「无效的」，最后把正在访问的页面装入到这个物理页中。

### 最佳页面置换算法

最佳页面置换算法基本思路是，置换在「未来」最长时间不访问的页面。

所以，该算法实现需要计算内存中每个逻辑页面的「下一次」访问时间，然后比较，选择未来最长时间不访问的页面。

我们举个例子，假设一开始有 3 个空闲的物理页，然后有请求的页面序列，那它的置换过程如下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/页面置换算法01.2wgngjl2xbs0.png)

在这个请求的页面序列中，缺页共发生了 7 次（空闲页换入 3 次 + 最优页面置换 4 次），页面置换共发生了 4 次。

这很理想，但是实际系统中无法实现，因为程序访问页面时是动态的，我们是无法预知每个页面在「下一次」访问前的等待时间。

所以，最佳页面置换算法作用是为了衡量你的算法的效率，你的算法效率越接近该算法的效率，那么说明你的算法是高效的。

### 先进先出置换算法

既然我们无法预知页面在下一次访问前所需的等待时间，那我们可以选择在内存驻留时间很长的页面进行中置换，这个就是「先进先出置换」算法的思想。

还是以前面的请求的页面序列作为例子，假设使用先进先出置换算法，则过程如下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/页面置换算法02.7afmxqmvhlk0.png)

在这个请求的页面序列中，缺页共发生了 10 次，页面置换共发生了 7 次，跟最佳页面置换算法比较起来，性能明显差了很多

### 最近最久未使用的置换算法

最近最久未使用（LRU）的置换算法的基本思路是，发生缺页时，选择最长时间没有被访问的页面进行置换，也就是说，该算法假设已经很久没有使用的页面很有可能在未来较长的一段时间内仍然不会被使用。

这种算法近似最优置换算法，最优置换算法是通过「未来」的使用情况来推测要淘汰的页面，而 LRU 则是通过「历史」的使用情况来推测要淘汰的页面。

还是以前面的请求的页面序列作为例子，假设使用最近最久未使用的置换算法，则过程如下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/页面置换算法03.3g5e8n36ic80.png)

在这个请求的页面序列中，缺页共发生了 9 次，页面置换共发生了 6 次，跟先进先出置换算法比较起来，性能提高了一些。

虽然 LRU 在理论上是可以实现的，但代价很高。为了完全实现 LRU，需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。

困难的是，在每次访问内存时都必须要更新「整个链表」。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常费时的操作。

所以，LRU 虽然看上去不错，但是由于开销比较大，实际应用中比较少使用。

### 时钟页面置换算法

那有没有一种即能优化置换的次数，也能方便实现的算法呢？

时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。

该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。

当发生缺页中断时，算法首先检查表针指向的页面：

如果它的访问位位是 0 就淘汰该页面，并把新的页面插入这个位置，然后把表针前移一个位置；
如果访问位是 1 就清除访问位，并把表针前移一个位置，重复这个过程直到找到了一个访问位为 0 的页面为止；
我画了一副时钟页面置换算法的工作流程图，你可以在下方看到：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/页面置换算法04.1f0v12op771c.png)

### 最不常用算法

最不常用（LFU）算法，这名字听起来很调皮，但是它的意思不是指这个算法不常用，而是当发生缺页中断时，选择「访问次数」最少的那个页面，并将其淘汰。

它的实现方式是，对每个页面设置一个「访问计数器」，每当一个页面被访问时，该页面的访问计数器就累加 1。在发生缺页中断时，淘汰计数器值最小的那个页面。

看起来很简单，每个页面加一个计数器就可以实现了，但是在操作系统中实现的时候，我们需要考虑效率和硬件成本的。

要增加一个计数器来实现，这个硬件成本是比较高的，另外如果要对这个计数器查找哪个页面访问次数最小，查找链表本身，如果链表长度很大，是非常耗时的，效率不高。

但还有个问题，LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。

那这个问题的解决的办法还是有的，可以定期减少访问的次数，比如当发生时间中断时，把过去时间访问的页面的访问次数除以 2，也就说，随着时间的流失，以前的高访问次数的页面会慢慢减少，相当于加大了被置换的概率。

## 虚拟技术你了解吗？

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

## 内存的覆盖是什么，有什么特点

由于程序运行时并不是任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分为一个**固定区**和若干个**覆盖区**。将经常活跃的部分放在固定区，其余部分按照调用关系分段，首先将那些即**将要访问的段放入覆盖区**，其他段放在外存中，在需要调用前，系统将其调入覆盖区，替换覆盖区中原有的段。

覆盖技术的特点：**是打破了必须将一个进程的全部信息装入内存后才能运行的限制**，但当同时运行程序的代码量大于主存时仍不能运行，再而，大家要注意到，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存。
