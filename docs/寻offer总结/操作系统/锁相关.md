<font color="green" size=4>更多读书笔记关注公众号:**零K同学**</font>

<!-- TOC -->

- [介绍一下几种典型的锁](#介绍一下几种典型的锁)
	- [互斥锁与自旋锁](#互斥锁与自旋锁)
		- [互斥锁](#互斥锁)
		- [自旋锁](#自旋锁)
	- [读写锁](#读写锁)
	- [乐观锁与悲观锁](#乐观锁与悲观锁)
- [什么是死锁](#什么是死锁)
	- [死锁发生的原因](#死锁发生的原因)
	- [如何避免和解决死锁](#如何避免和解决死锁)
	- [利用工具排查死锁问题](#利用工具排查死锁问题)
	- [怎么预防死锁](#怎么预防死锁)
		- [安全序列与银行家算法](#安全序列与银行家算法)
	- [C++11 加锁](#c11-加锁)

<!-- /TOC -->

-------


## 介绍一下几种典型的锁

> [参考](https://blog.csdn.net/qq_34827674/article/details/108608566)

> [死锁](https://blog.csdn.net/qq_34827674/article/details/115365866)


### 互斥锁与自旋锁

加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。

当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：

- **互斥锁**加锁失败后，线程会**释放 CPU** ，给其他线程；
- **自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁；

#### 互斥锁

互斥锁是一种「**独占锁**」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞。

**对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的**。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/互斥锁01.3761fjd0vri0.png)

所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。

那这个开销成本是什么呢？会有两次线程上下文切换的成本：

- 当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；

- 接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。

**线程的上下文切换的是什么**？

当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。

如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。

所以，**如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁**。

> 互斥锁是一种独占锁，就是当线程 A 加锁成功后，这个时候互斥锁被线程 A 独占了，线程 B 这个时候如果也加锁就会失败，于是就会释放 CPU 给其他线程，然后线程 B 就会进入堵塞状态，对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本(也就是线程上下文切换成本)。还有，一般锁住的代码执行时间比较短，那就不适用互斥锁，应该选用自旋锁，因为会有线程的开销。

#### 自旋锁

<u>自旋锁是通过 CPU 提供的 CAS 函数（Compare And Swap）来实现，在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</u>

一般加锁的过程，包含两个步骤：

第一步，查看锁的状态，如果锁是空闲的，则执行第二步；

第二步，将锁设置为当前线程持有；

CAS 函数就把这两个步骤合并成一条硬件级指令，形成原子指令，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。

使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 while 循环等待实现，不过最好是使用 CPU 提供的 PAUSE 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。

自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。需要注意，<u>**在单核 CPU 上，需要抢占式的调度器（即通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋锁的线程永远不会放弃 CPU**</u>。

自旋锁开销少，在多核系统下一般不会主动产生线程切换,适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。

自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：<u>**当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对**</u>。


它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。

> 自旋锁通过 CPU 的 CAS 函数实现，在用户态完成加锁和解锁操作，不主动产生线程上下文切换，相对于互斥锁开销小。
>
> 有两个步骤，查看锁是否空闲，空闲就加锁。CSA 函数把这两个步骤合并成一条硬件指令，原子子令，加锁失败「忙等待」，单核 CPU 需要抢占式调度器。

### 读写锁

<u>读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。</u>

<u>所以，**读写锁适用于能明确区分读操作和写操作的场景**。</u>

读写锁的工作原理是：

当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。

但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞。

所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。

知道了读写锁的工作原理后，我们可以发现，读写锁在读多写少的场景，能发挥出优势。

另外，根据实现的不同，读写锁可以分为「**读优先锁**」和「**写优先锁**」。

读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取写锁。如下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/读写锁01.6jyb40o4xz40.png)

而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取写锁。如下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/读写锁02.5q0wyim1ouk0.png)

读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。

写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。

既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「**公平读写锁**」。

**公平读写锁**比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。

互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。

> - 读锁，共享锁，多个线程可以并发持有，多读场景				
> - 写锁：独占锁，只有一个线程可以持有，多写场景		
> - 读优先锁，线程 A 加读锁，线程 B 加写锁就阻塞，线程 C 可以加读锁		
> - 写优先锁，线程 A 加读锁，线程 B 写堵塞，线程 C 读锁就失败		
> - 公平读写锁，用队列实现

### 乐观锁与悲观锁

前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。

悲观锁的话就是认为多线程同时修改共享资源的概率比较高，所以一开始就上锁了。

乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现乐观锁全程并没有加锁，所以它也叫无锁编程。

这里举一个场景例子：**在线文档**。我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。

放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。


**那么服务器是怎么验证是否发生冲突的呢**？

怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。

服务端要怎么验证是否冲突了呢？通常方案如下：

由于发生冲突的概率比较低，所以先让用户编辑文档，但是浏览器在下载文档时会记录下服务端返回的文档版本号；

当用户提交修改时，发给服务端的请求会带上原始文档版本号，服务器收到后将它与当前版本号进行比较，如果版本号一致则修改成功，否则提交失败。

实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。

乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁**。

> - 悲观锁，一开始就加锁
> - 乐观锁，发生冲突的概率很低，先改资源，再对比是否被修改		
> - 在线文档
> - 使用版本号判断是否发生冲突


## 什么是死锁

比如：当两个线程为了保护两个不同的 共享资源 而使用了两个互斥锁，那么这两个互斥锁应用不当的时候，可能会造成两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了**死锁**。


### 死锁发生的原因

- **互斥条件**： 多个线程不能同时使用同一个资源。

  比如下图，如果线程 A 已经持有的资源，不能再同时被线程 B 持有，如果线程 B 请求获取线程 A 已经占用的资源，那线程 B 只能等待，直到线程 A 释放了资源。

  ![](https://img-blog.csdnimg.cn/img_convert/95a7e0697e027ae4e4f50f02514ce814.png)

- **持有并等待条件**：当线程 A 已经持有了资源 1，又想申请资源 2，而资源 2 已经被线程 C 持有了，所以线程 A 就会处于等待状态，但是线程 A 在等待资源 2 的同时并不会释放自己已经持有的资源 1。

![](https://img-blog.csdnimg.cn/img_convert/6b1043066ee6845e40fec78ef2803a11.png)

- **不可剥夺条件**: 当线程已经持有了资源 ，在自己使用完之前不能被其他线程获取，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取。

![](https://img-blog.csdnimg.cn/img_convert/211980afed6fe33d8101d931dfd6d6bc.png)


- **循环等待**，也就是存在一个等待队列：P1 占有 P2 的资源，P2 占有 P3 的资源，P3占有 P1 的资源。这样就形成了一个等待环路。


### 如何避免和解决死锁

破坏请求条件：一次性分配所有资源，这样就不会再有请求了；

破坏请求保持条件：只要有一个资源得不到分配，也<u>不给这个进程分配其他的资源</u>：

破坏不可剥夺条件：当某进程获得了部分资源，但得不到其它资源，则<u>释放已占有的资源；</u>

破坏循环等待条件：系统给每类资源赋予一个**编号**，每一个进程按编号递增的顺序请求资源，释放则相反。

### 利用工具排查死锁问题

在 Linux 下，我们可以使用 pstack + gdb 工具来定位死锁问题。

pstack 命令可以显示每个线程的栈跟踪信息（函数调用过程），它的使用方式也很简单，只需要` pstack <pid>` 就可以了。

那么，在定位死锁问题时，我们可以多次执行 pstack 命令**查看线程的函数调用过程**，多次对比结果，确认哪几个线程一直没有变化，且是因为在等待锁，那么大概率是由于死锁问题导致的。

但是，还不能够确认这两个线程是在互相等待对方的锁的释放，因为我们看不到它们是等在哪个锁对象，于是我们可以使用 gdb 工具进一步确认。

### 怎么预防死锁

避免多个线程互相持有对方线程所需要的独占锁的的情况

- 设置**优先级**
- **超时**放弃

#### 安全序列与银行家算法

>  当一个进程申请使用资源的时候，银行家算法通过先 **试探** 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。

> [参考](https://qyliang.blog.csdn.net/article/details/80245715?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2.no_search_link)

为了避免死锁，我们在资源动态分配过程中，通过防止系统进入不安全状态，以避免发生死锁。

银行家算法正是通过判断“如果给一个进程分配它所需的资源后，是否会使得系统处于不安全状态”来判断是否分配资源给它，以达到上述目的。

**银行家算法**

- 尝试找一个安全系列， 
- 依次检查剩余的资源是否满足各个进程的需求，
- 如果可以满足 P1 的需求，那就把资源全部分配给 P1 进程，等 P1 执行结束了就会归还 P1 持有的资源，
- 接着又检查是否满足 P2 的需求，如果满足就把 P2 加入安全序列，并更新剩余可用资源
- 最后直到包含所有进程的安全序列
- 这时候系统是属于安全状态的，因此不会发生死锁



### C++11 加锁

https://www.bilibili.com/video/BV1pE411H7fd?from=search&seid=17617602973965907303

- std::lock_guard

- std::unique_lock



