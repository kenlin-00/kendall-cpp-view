

## MIT6.S081环境搭建

> 我的实验环境：VMware + Ubuntu20.04


### 安装工具

[参考](https://pdos.csail.mit.edu/6.828/2020/tools.html)

```
sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 


# 安装特定版本 QEMU
# 先卸载原有的
sudo apt-get remove qemu-system-misc
sudo apt-get install qemu-system-misc=1:4.2-3ubuntu6
```

> 注: 经过测试, 1:4.2-3ubuntu6 版本的 qemu-system-misc 软件包仅在 Ubuntu 20.04 发布, 因此建议使用此版本的 Ubuntu.



测试是否安装成功

```
sudo apt install gcc-riscv64-unknown-elf
riscv64-unknown-elf-gcc --version
qemu-system-riscv64 --version
```



### 克隆源码

[官网链接](https://pdos.csail.mit.edu/6.S081/2020/labs/util.html)

```
git clone git://g.csail.mit.edu/xv6-labs-2020

cd xv6-labs-2020/

# 检出util分支:
book@kenbook:~/kenspace/MIT6.S081/xv6-labs-2020$ git checkout util
Branch 'util' set up to track remote branch 'util' from 'origin'.
Switched to a new branch 'util'
book@kenbook:~/kenspace/MIT6.S081/xv6-labs-2020$ ls
conf  grade-lab-util  gradelib.py  kernel  LICENSE  Makefile  mkfs  README  user
```


如果克隆有问题可以直接用我下载好的压缩包

链接: https://pan.baidu.com/s/14OvCgiwkjWAlq63_-S-0yw?pwd=1djp 提取码: 1djp 


查看此代码的分支

```
book@100ask:~/kenspace/MIT6.S081/xv6-labs-2020$ git branch --remote
  origin/HEAD -> origin/master
  origin/cow
  origin/fs
  origin/lazy
  origin/lock
  origin/master
  origin/mmap
  origin/net
  origin/pgtbl
  origin/riscv
  origin/syscall
  origin/thread
  origin/traps
  origin/util
```

### 源码目录简析

- kernel：内核源码，system call的实现

- user：系统自带工具源码，shell、echo、cat等工具实现

- grade-lab-util：python实现的代码测试工具

- Makefile：make配置文件

### 构建并运行xv6:

```
book@kenbook:~/kenspace/MIT6.S081/xv6-labs-2020$ make qemu

# 进入之后，执行 ls
$ ls
.              1 1 1024
..             1 1 1024
README         2 2 2059
xargstest.sh   2 3 93
cat            2 4 23984
echo           2 5 22816
forktest       2 6 13192
grep           2 7 27344
init           2 8 23920
kill           2 9 22792
ln             2 10 22744
ls             2 11 26224
mkdir          2 12 22896
rm             2 13 22880
sh             2 14 41768
stressfs       2 15 23888
usertests      2 16 147528
grind          2 17 38008
wc             2 18 25128
zombie         2 19 22288
console        3 20 0
```


### 退出

按 Ctrl-a 松开后，再按 x

> 到目前为止环境已经搭建完成



----

## Mit6.S081-实验1-Xv6 and Unix utilities

### 实验目的

利用qemu启动xv6，并实现一些使用工具



```
# 切换到xv6-labs-2020代码库的lab1分支
book@kenbook:~/kenspace/MIT6.S081/xv6-labs-2020$ git checkout util
book@kenbook:~/kenspace/MIT6.S081/xv6-labs-2020$ make clean
book@kenbook:~/kenspace/MIT6.S081/xv6-labs-2020$ cd user/
```

- 编写第一个程序

> 将控制台输入内容输出到控制台

vim copy.c



```c
#include "kernel/types.h"
#include "user/user.h"

int main() 
{
   int len = 0;
   char buf[64];

    while(1)
    {

        //返回的就是读取的字节数
       len = read(0,buf,sizeof(buf));
       if(len == -1) {
            break;
       }
       else 
       {
            write(1,buf,len);
       }
    }

	exit(0);
}
```

在 Makefile 152 行加上

```
UPROGS=\
	$U/_cat\
	$U/_echo\
	$U/_forktest\
	$U/_grep\
	$U/_init\
	$U/_kill\
	$U/_ln\
	$U/_ls\
	$U/_mkdir\
	$U/_rm\
	$U/_sh\
	$U/_stressfs\
	$U/_usertests\
	$U/_grind\
	$U/_wc\
	$U/_zombie\
	$U/_copy\
```

```
make clean
make qemu
```

输入 copy 可以查看结果

```
$ copy
wwwww
wwwww
1234rfaffaa
1234rfaffaa
```

ctrl-a x  退出

----

### sleep

调用 system call sleep 来实现休眠一定时间，注意如果没有传入参数，程序需要打印错误信息

通过传入参数来控制 sleep 的时间

vim sleep.c

···c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int main(int argc, char **argv) 
{
	if(argc != 2)
	{
		//2是标准输出
		fprintf(2,"ERROR:  sleep time required \n");
		exit(-1);
	}
	sleep(atoi(argv[1]));
	exit(0);
}
···




### ping pong练习

写一个程序，使用unix system calls在两个进程间 "ping-pong" 一个字节，使用一对 pipe，一个 pipe 对应一个方向，另外一个 pipe 对应另外一个方向。

#### 实验代码

vim pingpone.c

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include <stddef.h>

// fd[0]用于读数据；
// fd[1]用于写数据；

int main(int argc, char **argv) {
	// 创建管道会得到一个长度为 2 的 int 数组
	// 其中 0 为用于从管道读取数据的文件描述符，1 为用于向管道写入数据的文件描述符
	int pp2c[2], pc2p[2];
	pipe(pp2c); // 创建用于 父进程 -> 子进程 的管道
	pipe(pc2p); // 创建用于 子进程 -> 父进程 的管道
	
	if(fork() != 0) { // parent process
		write(pp2c[1], "X", 1); // 1. 父进程首先向发出该字节
		char buf;
		read(pc2p[0], &buf, 1); // 2. 父进程发送完成后，开始等待子进程的回复
		printf("%d: received pong\n", getpid()); // 5. 子进程收到数据，read 返回，输出 pong
		wait(0);
	} else { // child process
		char buf;
		read(pp2c[0], &buf, 1); // 3. 子进程读取管道，收到父进程发送的字节数据
		printf("%d: received ping\n", getpid());
		write(pc2p[1], &buf, 1); // 4. 子进程通过 子->父 管道，将字节送回父进程
	}
	exit(0);
}
```

#### 实验结果


```
make qemu

$ pingpong
pid = 11,received pong
pid = 10,received ping
```


#### 测试结果

评测脚本 grade-lab-util 是 python 程序。因为 ubuntu 的 python 在 `/usr/bin` 下，所以需要对测试脚本进行修改

```
#!/usr/bin/env python

# 修改为：

#!/usr/bin python
```

测试命令为：

```
python3 grade-lab-util pingpong
```

### primes实验

将 2~35 中的素数打印出来，要求利用管道理念。

参考[这篇文章](https://swtch.com/~rsc/thread/)

#### 实验代码


> 可以参考思路：https://zhuanlan.zhihu.com/p/100051075

```c
#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

#define NUM 34  //定义有多少个数

void func_prime(int pleft[2])
{
	//读取第一个数，必然是素数
	int prime;
	read(pleft[0],&prime,sizeof(prime));
	if(prime == -1) //结束
	{
		exit(0);
	}
	printf("prime %d\n",prime);  //注意档案这里没有冒号

	//创建下一个管道
	int pright[2];
	pipe(pright);

	if(fork() == 0) //子进程
	{
		// 继续 下一个 stage
		close(pright[1]);
		close(pleft[0]);  //左边的管道不需要读了
		func_prime(pright);
	} 
	else //父进程
	{
		int buf;
		//把当前的管道读出来,然后写进右边的管道
		close(pright[0]);
		while(read(pleft[0],&buf,sizeof(buf)) && buf != -1)  //并且没到结束
		{
			// 筛掉能被该进程筛掉的数字，不能整除
			if(buf % prime != 0)
			{
				//写进右边的管道
				write(pright[1],&buf,sizeof(buf));
			}

		}
		//写入结束标志
		buf = -1;
		write(pright[1],&buf,sizeof(buf));
		// 等待该进程的子进程完成，也就是下一 stage
		wait(0);
		exit(0);
	}
}


int main()
{
	//首先需要创建第一个输入管道
	int input_pipe[2];
	pipe(input_pipe);

	if(fork() == 0)  //子进程
	{
		//读第一个 stage 
		close(input_pipe[1]);
		//读的时候需要处理是不是素数
		func_prime(input_pipe);
		exit(0);
	}
	else   //父进程
	{
		//主进程只需要写如管道，不需要读
		close(input_pipe[0]);
		int i;
		//将 2~35 输入到第一个管道
		for(i=2;i<=35;i++)
		{
			write(input_pipe[1],&i,sizeof(i));
		}
		// 最后写入-1作为结束标志
		i = -1;
		write(input_pipe[1],&i,sizeof(i));
	}
	//父进程需要等待子进程结束才会退出
	wait(0);  //注意这里不会等待子进程的子进程，只能在子进程中再次执行 wait(0) ，形成一个等待链
	exit(0);
}
```

### find实验

实现 find ，即在某个路径中，找出某个文件。

