- [环境搭建](#环境搭建)
- [第4章 文件IO](#第4章-文件io)
  - [文件描述符](#文件描述符)
- [第4章](#第4章)
  - [stat](#stat)
  - [access](#access)
  - [umask](#umask)
  - [文件的长度](#文件的长度)
  - [文件空洞](#文件空洞)
  - [truncate](#truncate)
  - [文件系统](#文件系统)
- [第5章](#第5章)
  - [缓冲](#缓冲)


---


> linux_unix 系统编程手册

## 环境搭建

到这里去下载源码：`https://man7.org/tlpi/code/index.html`

```sh
$ tar zxf tlpi-220505-dist.tar.gz 

$ ls
tlpi-220505-dist.tar.gz  tlpi-dist
$ cd tlpi-dist
$ make
```

报错：

```
userns_functions.c:25:10: fatal error: sys/capability.h: No such file or directory
   25 | #include <sys/capability.h>
      |          ^~~~~~~~~~~~~~~~~~
compilation terminated.
make[1]: *** [<builtin>: userns_functions.o] Error 1
```

- 问题解决

> 这是因为缺少开发库 `libcap-devel` ，所以需要安装开发库

```
sudo apt-get install libcap-dev
```

重新 make

```
make all
```


又有新的错误

```
ameter    acl_update.c ../libtlpi.a  ../libtlpi.a -lacl -o acl_update
acl_update.c:23:10: fatal error: sys/acl.h: No such file or directory
   23 | #include <sys/acl.h>
      |          ^~~~~~~~~~~
compilation terminated.
make[1]: *** [<builtin>: acl_update] Error 1
```

- 问题解决

```
sudo apt-get install uuid-dev libacl1-dev liblzo2-dev
```


重新 make

```
make all
```

**成功**

----

## 第4章 文件IO

> 我采用的方法时在每个源码文件夹下自己创建一个新的文件，然后在 Makefile 中添加文件名

比如我在 fileio 文件下子啊创建一个 copyken.c 文件，在 Makefile 中添加

```
GEN_EXE = atomic_append bad_exclusive_open copy \
	multi_descriptors seek_io t_readv t_truncate \
    copyken   # copyken 为添加的内容
```

最后直接通过 `make copyken` 就可以编译啦


### 文件描述符

大多数文件都能使用 3 种文件描述符，具体见如下表，

|  文件描述符   | 用途  |  POSIX名称   | stdio流  |
|  ----  | ----  |  ----  | ----  |
| 0  | 标准输入 |  STDIN_FILENO  | stdin |
| 1  | 标准输出 |  STDOUT_FILENO  | stdout |
| 2  | 标准错误 |  STDERR_FILENO  | stderr |

程序在运行之前 shell 就已经打开了这 3 个文件描述符，所以说一般情况下，这三个文件描述符是默认打开的。




-----

## 第4章

### stat

获取文件信息，保存在 stat 结构体中

### access

查看文件是否有访问权限，R_OK, W_OK, X_OK

### umask

设置创建文件的默认权限，umask(0) 是不屏蔽任何权限

### 文件的长度

- 普通文件的长度开始是 0 ，目录文件长度通常是 16 或者 512，链接文件的文件长度是「文件名中的实际字节数」（不包括 null)

### 文件空洞

如果程序的文件偏移量已经跨域了文件结尾，在调用 `read()` 系统函数，就会返回 0，表示文件结尾。但是 `write()`  却可以在文件结尾后的任意位置写入数据。

- **从文件结尾后到新写入数据的这段空间被称为「文件空洞」**，读取文件空洞就会返回以 0（空字节）填充的缓冲区。

- **然后文件空洞是不占用磁盘空间的**。一直写入到某个点时，系统才会为它分配磁盘块（直接分配一个内存块）。

- 文件空洞的优势：**与为实际需要的空字节分配磁盘块相比，稀疏填充的文件会占用较少的磁盘空间。**

### truncate

截断文件，最终的文件长度是 length

```c
int truncate(const char *path, off_t length);
int ftruncate(int fd, off_t length);
```

### 文件系统

i 节点数组  数据块  数据块 目录快

i 节点数组中每个 i 节点都指向一个数据块或者目录快

- 每个 i 节点都有一个「链接技术」，保存着这个 i 节点的目录项数，只有当链接计数为 0 时才能删除该文件（也就是释放该文件的数据块）。解除一个文件的链接 并不意味着 释放文件占用的磁盘块


----

## 第5章

### 缓冲

- 行缓冲
  - 标准 I/O 库用来收集每一行的缓冲区的长度是固定的，所以只要缓冲区填满了，即使没有写入一个换行符，也会执行 I/O 操作。
  - 读取缓冲区数据的数据，就会冲刷所有缓冲区输出流

