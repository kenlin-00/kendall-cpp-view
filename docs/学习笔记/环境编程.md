- [环境搭建](#环境搭建)
- [第4章 文件IO](#第4章-文件io)
  - [文件描述符](#文件描述符)
- [第30章 线程同步](#第30章-线程同步)
  - [条件变量](#条件变量)


---


> linux_unix 系统编程手册

## 环境搭建

到这里去下载源码：`https://man7.org/tlpi/code/index.html`

```sh
$ tar zxf tlpi-220505-dist.tar.gz 

$ ls
tlpi-220505-dist.tar.gz  tlpi-dist
$ cd tlpi-dist
$ make
```

报错：

```
userns_functions.c:25:10: fatal error: sys/capability.h: No such file or directory
   25 | #include <sys/capability.h>
      |          ^~~~~~~~~~~~~~~~~~
compilation terminated.
make[1]: *** [<builtin>: userns_functions.o] Error 1
```

- 问题解决

> 这是因为缺少开发库 `libcap-devel` ，所以需要安装开发库

```
sudo apt-get install libcap-dev
```

重新 make

```
make all
```


又有新的错误

```
ameter    acl_update.c ../libtlpi.a  ../libtlpi.a -lacl -o acl_update
acl_update.c:23:10: fatal error: sys/acl.h: No such file or directory
   23 | #include <sys/acl.h>
      |          ^~~~~~~~~~~
compilation terminated.
make[1]: *** [<builtin>: acl_update] Error 1
```

- 问题解决

```
sudo apt-get install uuid-dev libacl1-dev liblzo2-dev
```


重新 make

```
make all
```

**成功**

----

## 第4章 文件IO

> 我采用的方法时在每个源码文件夹下自己创建一个新的文件，然后在 Makefile 中添加文件名

比如我在 fileio 文件下子啊创建一个 copyken.c 文件，在 Makefile 中添加

```
GEN_EXE = atomic_append bad_exclusive_open copy \
	multi_descriptors seek_io t_readv t_truncate \
    copyken   # copyken 为添加的内容
```

最后直接通过 `make copyken` 就可以编译啦


### 文件描述符

大多数文件都能使用 3 种文件描述符，具体见如下表，

|  文件描述符   | 用途  |  POSIX名称   | stdio流  |
|  ----  | ----  |  ----  | ----  |
| 0  | 标准输入 |  STDIN_FILENO  | stdin |
| 1  | 标准输出 |  STDOUT_FILENO  | stdout |
| 2  | 标准错误 |  STDERR_FILENO  | stderr |

程序在运行之前 shell 就已经打开了这 3 个文件描述符，所以说一般情况下，这三个文件描述符是默认打开的。



----

## 第30章 线程同步

### 条件变量

互斥量防止多线程同时访问同一共享变量，条件变量允许一个线程就某个共享变量（或者其他共享资源）的状态变化通知其他线程，让其他线程阻塞等待这一通知。

条件变量的主要操作是发送信号和等待，发送信号也就是通知一个或者多个处于等待的线程，告诉它等待的线程的状态已经发生改变了。

```c
int pthread_cond_signal(pthread_cont_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);
```

上面两个函数都是针对参数 cond 所指定的条件变量而发送信号，但是两者对阻塞于 `pthread_cond_wait` 的多个线程的处理方式不同， `pthread_cond_signal` 只会唤醒一个阻塞的线程，而 `pthread_cond_broadcast` 会唤醒所有被阻塞的线程。

> `pthread_cond_signal` 的效率相对于 `pthread_cond_broadcast` 更高。

