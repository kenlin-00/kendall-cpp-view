## 1.从尾到头打印链表
[题目来源](https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&tqId=11156&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)

输入一个链表，按链表从尾到头的顺序返回一个`ArrayList`。

题解一：使用标准库函数

```cpp
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> ret;
        if(head == NULL) return ret;
       while(head) {
           ret.push_back(head->val);
           head = head->next;
       }
        reverse(ret.begin(), ret.end());
        return ret;
    }
};
```

题解二：反转链表

```cpp
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        vector<int> ret;
        if(!head) return ret; 
        ListNode *p = head;
        ListNode *q = head->next;
        head = NULL;
        while(q) {
            p->next = head;
            head = p;
            p = q;
            q = q->next;
        }
        
         p->next = head;
         head = p;
//         ret.push_back(p->val);  更慢
        while(head) {
            ret.push_back(head->val);
            head = head->next;
        }
        return ret;
    }
};
```

## 2.链表中倒数第 k 个节点

[题目来源](https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&tqId=11167&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)

输入一个链表，输出该链表中倒数第k个结点。

示例：
```
输入
{1,2,3,4,5},1
输出
{5}
```
题解：

使用两个指针，一个指针先走 K 步，然后第二个指针开始走，当第一个指针走到结束位置的时候第一个指针就是走到倒数第 k 位置。

```cpp
/**
 * struct ListNode {
 *	int val;
 *	struct ListNode *next;
 *	ListNode(int x) : val(x), next(nullptr) {}
 * };
 */
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param pHead ListNode类 
     * @param k int整型 
     * @return ListNode类
     */
    ListNode* FindKthToTail(ListNode* pHead, int k) {
        ListNode *fast = pHead;
        ListNode * slow = pHead;
        for(int i=0;i<k;++i) {
            if(fast == nullptr) return nullptr;
            fast = fast->next;
        }
        while(fast) {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

## 3,合并两个排序的链表

[题目来源](https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)

输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

```cpp
输入：{1,3,5},{2,4,6}

输出：{1,2,3,4,5,6}
```
遍历 `p2`,逐个插入`p1`中，注意必须记住`p1`的前面一个节点，否则最后`p1`为空的时候退出循环，将无法插入`p2`后半部分
```cpp
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2) {
        if(pHead1 == nullptr) return pHead2;
        if(pHead2 == nullptr) return pHead1;
        
        ListNode *p1 = pHead1;
        ListNode *p2 = pHead2;
        ListNode *ptr2;
        ListNode *ptr1;
        while(p1 && p2) {
            ptr2 = p2->next;
            while(p1 && p1->val < p2->val) {
                ptr1 = p1;
                p1 = p1->next;
            }
            
            if(p1) {
                ptr1 = p1;
                swap(p1->val,p2->val);
                p2->next = p1->next;
                p1->next = p2;
                p1 = p2;
                p2 = ptr2;
            }
        }
        if(p1 == nullptr) {
            ptr1->next = p2;  //注意不能直接用p1 = p2;
        }
        return pHead1;
    }
};
```

## 4.复杂的链表复制

[题目来源](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&tab=answerKey)

输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

题解：先复制每个节点，再取出复制的节点作为链表

```cpp
/*
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};
*/
class Solution {
public:
    RandomListNode* Clone(RandomListNode* head) {
        //复制每个节点
        //在两个节点之间插入
        //1. 复制每个结点 next
            //在两个结点之间新建一个结点  复制前驱
        for(auto p = head; p;)
        {
            auto newp = new RandomListNode(p -> label);
            //在p  和  p -> next之间插入newp
            auto temp = p -> next;
            p -> next = newp;
            newp -> next = temp;
            p = temp;
        }
        
        //random
        //a -> next -> ramdom = a -> random -> next;
        for(auto p = head; p; p = p -> next -> next)
        {
            if(p -> random)
                p -> next -> random = p -> random -> next;
        }
        
        auto dummy = new RandomListNode(-1);
        
        auto cur = dummy;
        for(auto p = head; p; p = p -> next)
        {
            cur -> next = p -> next;//A'
            cur = cur -> next;
            p -> next = p -> next -> next;
        }
        
        return dummy -> next;
    }
};
```