
大家好，我是【零K同学】，专注于分享读书笔记的 Linux 开发工程师，点击左上角蓝字关注


**今天来聊一些比较基础的东西，就是计算机中的各种单位，【比特，字，字节】都是什么？**

计算机由几亿万个位(bit)组成，每个字节存储的都是 0，1 二进制.一般 8 个位组成一个字节（byte)，当然不同机器不一样。

每个字节类似一个存储单元，但是这样的一个存储单元有点小，所以有些机器把多个字节连接在一起，组成一个更大的内存单位，称为为【字】。一个字一般由 2 个 或者 4 个字节组成。所以呢，每个字包含了更多的位，每个字可以容纳的无符号整数范围是 `0 ~ 4294967295` (2<sup>32</sup>-1),可以容纳的有符号整数范围是 `-2147483648` (-2<sup>31</sup>) ~ `2147483647` (2<sup>31</sup>-1)。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/字和直接01.2nxcg451ni40.png)

### 变量是什么

每个字都有属于自己的一个地址，但是这地址太难记了，所以就用一个名字和这个内存地址位置关联起来，这就是【变量】。但是**变量是由编译器为我们实现的，硬件仍然通过地址访问内存位置**。看看下面这张图就可以很清楚的知道啦。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-01/变量.2s24hubb6ts0.png)

> 这里是否有同学会问，那么一个字里面只存储一个字符，也需要 4 个字节，这样是不是浪费呢？	
> 
> 回答这个问题，就要引出大名鼎鼎的“字节对齐”啦！

### 扒一扒内存对齐

**内存对齐是一种用空间换时间以提高效率的方式**。

> **为什么会有内存对齐**？

主要是两个原因

- 平台原因：不是所有的硬件平台都能访问任意内存地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。为了同一个程序可以在多平台运行，需要内存对齐。

- 硬件原因：经过内存对齐后，`CPU`访问内存的速度大大提升。

可以看一下这段 C 代码输出的各个数据类型大小是多少？

```cpp
#include <stdio.h>

struct node
{
	int num;
	char ch;
}st;

int main() {
	int a[100];
	char b[100];
	printf("sizeof(int):\t %zu\n",sizeof(int));
	printf("sizeof(char):\t %d\n",(int)sizeof(char));
	printf("sizeof(a):\t %d\n",(int)sizeof(a));
	printf("sizeof(b):\t %d\n",(int)sizeof(b));
	printf("sizeof(st):\t %d\n",(int)sizeof(st));
	return 0;
}

```

看一下和自己想的结果一样么， 我们来逐一分析一下。

其输出的结果依次为：

```
sizeof(int):     4
sizeof(char):    1
sizeof(a):       400
sizeof(b):       100
sizeof(st):      8
```

此时会发现，和单纯计算字节数的话是有一些误差的。这就是因为内存对齐的原因。

> **来看一下内存对齐和非内存对齐产生的效果区别**。

`CPU`读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是`2，4，8，16`个字节，具体取多少个字节取决于硬件。

假设`CPU`把内存划分为`4`字节大小的块，要读取一个`4`字节大小的`int`型数据，来看一下这两种情况下`CPU`的工作量：

- 第一种就是内存对齐的情况，如图

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存对齐01.png)

一字节的 `char` 占用了四个字节，空了三个字节的内存地址，`int` 数据从地址`4`开始。此时，直接将地址 `4，5，6，7` 处的四个字节数据读取到即可。

- 第二种是没有内存对齐的情况如图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/寻offer总结/内存对齐02.png)

`char` 型的数据和`int`型的数据挨在一起，这个 `int` 数据从地址 `1` 开始，那么 `CPU` 想要读这个数据的话,来看看需要几步操作：

因为 `CPU` 是四个字节四个字节来寻址，

首先 `CPU` 读取 `0，1，2，3` 处的四个字节数据

然后 `CPU` 读取 `4，5，6，7` 处的四个字节数据

最后还要合并地址 `1，2，3，4` 处四个字节的数据才是本次操作需要的 `int` 数据。此时**一共需要两次寻址，一次合并的操作**。

> 大家可能会发现内存对齐岂不是浪费的内存资源么？

是这样的，但事实上，相对来说计算机内存资源一般都是充足的，我们更希望的是提高运行速度。

编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响。

-----

> 参考《代码随想录》

> 《C和指针》读书笔记

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-02/公众号二维码.75dvf969t4w0.png)


