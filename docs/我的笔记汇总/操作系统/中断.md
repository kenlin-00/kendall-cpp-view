
我们平时说的中断一般都是在保护模式下的中断，但是在实模式下也有中断，只是实模式下存储中断处理程序入口的表叫【中断向量表】，而保护模式下存放中断处理程序入口的表叫【中断描述符表】。

> 这里这对中断描述符表进行讨论。

## 中断描述符表

相对于中断向量表

- 中断描述符表地址不限制，在哪都可以
- 中断描述符表中的每个描述符用 8 个字节描述

顾名思义，中断描述表就是存放中断描述符的，但是，除此之外，还有任务门描述符和陷阱门描述符这些。因为所有描述符记录的都是程序的起始地址（入口），所以中断描述符表中的描述符都有自己的名称（XXX 门）。

一个中断源会产生一个中断向量，每个中断向量都对应中断描述符表中的一个门描述符，中断源就是通过中断向量对应到门描述符，然后通过门描述符找到对应的中断处理程序的。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/linux笔记01/中断源.4rda0unfzdo0.png)

中断描述符表（IDT）的位置是不固定的，当发生中断时，CPU 首先需要找到中断描述符表，那 CPU 是怎么找到它的呢？

其实，在 CPU 内部有个中断描述符表寄存器（IDTR），这个寄存器有两部分：

- 第 0~15 位是表界限，也就是 IDT 大小减 1
- 第 16~47 位是 IDT 的基地址

中断描述符表通过 IDTR 寄存器找到中断向量处理程序，这样中断系统才能正常运作。

IDTR 结构如下所示，其中 16 位表界限，表示最大寻址范围是 0xffff（65535B=64KB），可以容纳 64KB/8=8K=8192 个描述符。需要注意的是在门描述符中有个 P 位，所以在构建 IDT 时，需要把 P 位置置为 0，这样就表示门描述符的中断处理程序不在内存中。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/linux笔记01/IDTR寄存器.5cygdg2t84g0.png)


## 中断处理过程

- 处理器根据中断向量号定位中断描述符

中断向量号就是中断描述符的索引，当 CPU 收到一个 CPU 外部传进来的中断向量号后，就利用这个中断向量号在中断描述符表中找到对应的中断描述符，然后再根据中断描述符定位到中断处理程序。

> **中断向量号 * 8 + IDTR 中的地址 = 中断描述符的地址**

- CPU 进行特权级检查

对于软件主动发起的软中断，为了防止位于 3 特权级下的用户程序主动调用某些职位内核服务的例程，需要保证当前特权级 【门描述符 DPL $\geq$ 特权级 CPL $>$ 门中目标代码段 DPL】。如果满足就就就进入下一步的“门框“检查，否则 CPU 就跑出异常。

- 执行中断处理程序

进行特权级检查通过后，将门描述符目标代码段选择子加载到代码段寄存器 CS 中，把门描述符中中断处理程序的偏移地址加载到 EIP 中，开始执行中断处理程序。

> **EIP寄存器，用来存储CPU要读取指令的地址，CPU通过EIP寄存器读取即将要执行的指令。每次CPU执行完相应的汇编指令之后，EIP寄存器的值就会增加。**

中断在发生时，CPU 收到一个中断向量号，根据这个中断号在中断描述符表中找到相应的中断门描述符，门描述符中保存的是中断处理程序所在代码段的选择子以及在段内偏移量。当当前进程被中断打断后，为了保证中断返回后能继续运行该进程，CPU 会自动把 CS 寄存器和 EIP 寄存器的当前值保存到中断处理程序使用的栈中。至于中断处理程序使用的是哪个栈，要看它但是所在的特权等等级，因为中断是可以在任何特权等级下发生的。