<font color="blue" size=4>大家好，我是零K同学，专注于分享读书笔记的 Linux 开发工程师，点击左上角 蓝字 关注公众号【零K同学】。</font>

----

- [CPU的组成](#cpu的组成)
	- [存储器是什么](#存储器是什么)
	- [总线取指令过程](#总线取指令过程)
		- [地址总线](#地址总线)
	- [数据总线](#数据总线)
	- [控制总线](#控制总线)
- [那CPU咋寻址的呢](#那cpu咋寻址的呢)
- [CPU的工作原理](#cpu的工作原理)
- [关于寄存器的简单梳理](#关于寄存器的简单梳理)


----

## CPU的组成

我们应该都知道，**CPU 的唯一任务就是执行指令**，也就是一串串 010101.....。CPU 从逻辑上可以划分成3个模块，分别是**控制单元**、**运算单元**和**存储单元**，这三部分由CPU内部总线连接起来。如下所示：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/linux笔记01/CPU的组成01.1mvnfi9wgccg.png)

- 控制单元是整个 CPU 的指挥控制中心，有程序计数器 PC（Program Counter）, 指令寄存器 IR (Instruction Register)、指令译码器 ID (Instruction Decoder)和 操作控制器 OC (Operation Controller)等，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出各条指令，放在指令寄存器 IR 中，通过指令译码（分析）确定应该进行什么操作，然后通过操作控制器 OC，按确定的时序，向相应的部件发出微操作控制信号。

- 运算单元：是运算器的核心。可以执行算术运算(包括加减乘数等基本运算及其附加运算)和逻辑运算(包括移位、逻辑测试或两个值比较)。，运算器接收控制单元的命令而进行动作，

- 存储单元：包括 CPU 片内缓存和寄存器组，是 CPU 中暂时存放数据的地方，里面保存着那些等待处理的数据，或已经处理过的数据。CPU 访问寄存器所用的时间要比访问内存的时间短。采用寄存器，可以减少 CPU 访问内存的次数，从而提高了 CPU 的工作速度。但因为受到芯片面积和集成度所限，寄存器的容量不可能很大。

### 存储器是什么

存储被划分成很多个存储单元，比如划分成 128 个存储单元，如下图所示，然后一个存储单元可以存储 1byte 的信息，也就是 1 字节，通常 1 字节 由 8bit 或者 4bit 组成。所以对于拥有 128 个存储单元的存储器，可以说它的存储容量就是 128 字节。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/linux笔记01/存储器.6s98uduvre80.png)

CPU 如果想要从内存中 读和写 数据，就需要指定存储单元的地址，知道地址在哪才能找得到呀，对吧！然后需要连接 CPU 和内存的导向，这就是【总线】。

### 总线取指令过程

> **总线由分成 3 类：地址总线，数据总线，控制总线**

下图展示了 CPU 从 3 号单元中读取数据的过程。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/linux笔记01/总线01.17xxsum1rruo.png)

- CPU 通过地址线将地址信息 3 发出
- CPU 通过控制线发出内存读命令，并通知内存要从中取出数据
- 存储器将 3 号单元中的数据 08 通过数据线送入 CPU。

#### 地址总线

CPU 是通过地址总线来指定存储单元的，一个 CPU 有 N 根地址线，也就是地址总线的宽度为 N，这样的 CPU 的寻址能力就是 2<sup>N</sup>，也就是可以寻找 2 的 N 次方个内存单元。

比如一个 CPU 有 10 根地址总线，我们知道一根导向可以传送的状态只有两种，高电平和低电平，用二进制表示就是 1 或 0，10 根导线可以传送 10 位 二进制数据，10 根导线有 2<sup>10</sup> 个不同的数据，最小为 0 ，最大为 1023。

 举个例子：一个 CPU 的寻址能力为 8KB ，那么它的地址总线宽度为 13，因为 8kb = 8*1024B = 2<sup>13</sup>

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/linux笔记01/地址总线.740qm735fw40.png)

### 数据总线

CPU 与内存的数据传送是通过数据总线来进行的，8 根数据总线一次可以传送一个 8 位二进制数据（也就是一个字节）。

> 8086 数据总线有 16 为数据线，那么一次可以传 16 位数据（16 个二进制），同样的数据给 8088 数据总线，有 8 为数据线，那么一次可以传 8 为数据，就需要写两次。

- **8 位数据总线上传送 89D8（2次）**【8088 数据总线】

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/linux笔记01/数据总线01.1e4dadchkx0g.png)

- **16 位数据总线上传送 89D8（1次）**【8086 数据总线】

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/linux笔记01/数据总线02.3bafb7inc9e0.png)

### 控制总线

CPU 通过控制总线来对外部器件进行控制，控制总线决定 CPU 对外部器件的控制能力。

## 那CPU咋寻址的呢

我们这里以 16 位结构的 8086CPU 为例来介绍，首先来介绍下什么是 16 位结构的 CPU。

- 运算器一次最多可以处理 16 位的数据
- 寄存器的最大宽度是 16 位
- 寄存器和运算器之间的通路为 16 位

简单地说就是，在 8086 内部，**能够一次性处理、传输、暂时存储的信息的最大长度为 16 位**。

但是 8086CPU 有 20 位总线，可以传送 20 位地址，也就是说它的寻址能力为 2<sup>20</sup>=1048576B = 1024KB = 1M 。但是吧，8086CPU 又是 16 位结构，它能够一次性处理、传输、暂时存储的信息的最大长度为 16 位，只能传送 16 位地址，所以它的寻址能力只有 2<sup>16</sup>=65536B = 64KB。所以就有了【分段机制】，将两个 16 位地址合成一个 20 位的物理地址。

分段机制的做法是：**物理地址 = 段地址 x 16 + 偏移地址**

- 首先 CPU 的相关部件需要提供 16 位的段地址和偏移地址，并通过总线传给加法器
- 由加法器将这两个 16 位地址合成一个 20 位的物理地址
- 然后加法器通过总线将 20 位地址送入输入输出控制电路
- 输入输出控制电路将 20 位物理地址送到地址总线
- 最后由地址总线传送到存储器，找到对应的存储单元。

> **那么在加法器内部，是怎么将段地址和偏移地址合成物理地址的呢？**

我们来举个例子，假如 8086CPU 要访问地址为 123CH 的内存单元

首先相关部件提供段地址 1230 和偏移地址 00C8，在加法器中首先将 段地址x16 = 12300，再和偏移地址相加得到物理地址。

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/linux笔记01/地址加法器.1155o09wiocw.png)

> 一个数据的十六进制形式左移 1 位，相当于乘以 16，一个 X 进制的数据左移 1 位，相当于乘以 X。

**那为什么要 `x16` 呢**？借鉴《王爽老师的汇编语言》书中的例子，比如从学校到图书馆距离是 2826，先走 2000 米到体育馆，再走 826 米到图书馆。但是如果想用一张纸计算 2000 + 826，但是这张纸只能写 3 位数字，那 2000 怎么写呢？采用的方法就是用三位数的 200x10 得到 2000 的方式。如下图：

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/linux笔记01/为什么x16.2tgcan2vwtc0.png)

段地址是存在 CS 寄存器，偏移地址是存在 IP 寄存器中。cs: ip 指示了 CPU 当前要读取指令的地址，

## CPU的工作原理

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/linux笔记01/CPU的工作.30v9zl5b5500.png)


现在结合上图简单说下 CPU 的工作过程

控制单元要取出下一条运行的指令，这个指令在程序计数器 PC 中，在 x86CPU 上，程序计数器就是 cs: ip（其实就是 cs 寄存器和 ip 寄存器），所以读取 ip 寄存器后，将这个地址送到 【地址总线】。

- 这个时候 CPU 就可以根据这个地址得到了【指令】，然后将这个指令存入指令寄存器 IR 中。

> CPU 给一串字符串给地址总线，地址总线将这一字符串映射成地址，CPU 才能访问该地址。

- 接着由控制单元当中的指令译码器 ID 来分析这个指令是什么操作，然后确定操作码，

- 指令译码器 ID 还要去检查操作数的类型，如果操作数在内存中就直接将操作数放到自己的存储单元中，如果在寄存器中就将这个操作数和操作码一并传递给【运算单元】，由运算单元执行指令。

- 最后控制单元又取下一条指令，就这样循环下去一直到 CPU 断电。

## 关于寄存器的简单梳理

> 上面说了很多寄存器，所以这里先简单总结一下各种寄存器

- CS 寄存器 和 IP 寄存器

这一组寄存器非常重要，一般写为：`cs: ip`

CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址，其中 **CS 为代码段寄存器**，而 **IP 为指令指针寄存器**(相当于偏移地址）。CPU 执行指令时，通过代码寄存器 CS 和指令指针寄存器 IP 来确定要执行的下一条指令的内存地址。

修改 CS、IP 的指令不同于修改通用的寄存器值的指令，修改通用寄存器的值可以用 mov 指令（`mav ax,123`），mov 指令被称为传送指令。而修改 CS、IP 的指令是 jmp 指令。jmp 指令被称为跳转指令.

- `AX,BX,CX,DX` 寄存器

这四个寄存器也被称为**通用寄存器**.一般**用来存放数据**,一个寄存器可以存放 16bit ,也就是 2bytes. 所以也被称为 16 位寄存器。

这四个寄存器可以被分为两个 8 位寄存器，比如

```
AX = AH + AL， BX = BH+BL, CX = CH + CL,  DX = DH+DL
```

- DS 寄存器和 ES 寄存器

  - DS 数据段寄存器
  - ES 附加段寄存器

它们属于**段寄存器**，不能直接保存数据，只能通过其他的通用寄存器转存数据。它们俩没有明显的区别，但是 DS 是其他指针寄存器的默认段寄存器

- SS：堆栈段寄存器，存放堆栈的底部地址，

- ES: 扩展段寄存器，前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段；

- FS: 标志段寄存器，80386 起增加的两个辅助段寄存器之一，在这之前只有 es 寄存器；

- SP: 堆栈指针寄存器， SP(stack pointer) 存放栈的偏移地址;

- GS: 全局段寄存器

> `ds, es, fs, gs` 这类寄存器属于 sreg（状态寄存器），CPU 不能直接给它们赋值，只能通过其他寄存器来传入，比如可以使用 ax 寄存器来中转。所以不能写成 `mov ds: 0x7c00`，*<u>0x7c00 是主引导记录起始地址。</u>*

> 参考《操作系统真象还原》《王爽的汇编语言》

----

<font color="green" size=4>获取更多读书笔记关注公众号：**零K同学**<font>

![](https://cdn.jsdelivr.net/gh/kendall-cpp/blogPic@main/blog-img-02/公众号二维码.75dvf969t4w0.png)



